<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.53" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://gitee.com/oucystong/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html"><meta property="og:site_name" content="Zuooの学习笔记"><meta property="og:title" content="面试题记录"><meta property="og:description" content="1.电商钱包 业务背景：电商业务中，需要给电商app设计一个用户钱包，用户可以往钱包中充值，购买商品时用户可以使用钱包中的钱消费，商品申请退款成功后钱会退回钱包中，用户也可以申请提现把钱提到银行卡中 用程序实现如下api接口 1. 查询用户钱包余额 2. 用户消费100元的接口 3. 用户退款20元接口 4查询用户钱包金额变动明细的接口 请给出建表语句..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="article:tag" content="面试题"><meta property="article:tag" content="java"><meta property="article:tag" content="后端"><link rel="icon" href="/favicon.svg"><title>面试题记录 | Zuooの学习笔记</title><meta name="description" content="1.电商钱包 业务背景：电商业务中，需要给电商app设计一个用户钱包，用户可以往钱包中充值，购买商品时用户可以使用钱包中的钱消费，商品申请退款成功后钱会退回钱包中，用户也可以申请提现把钱提到银行卡中 用程序实现如下api接口 1. 查询用户钱包余额 2. 用户消费100元的接口 3. 用户退款20元接口 4查询用户钱包金额变动明细的接口 请给出建表语句...">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/mynotes/assets/style.f39ce7cc.css" as="style" /><link rel="stylesheet" href="/mynotes/assets/style.f39ce7cc.css" />
    <link rel="modulepreload" href="/mynotes/assets/app.fea2bdf4.js"><link rel="modulepreload" href="/mynotes/assets/面试.html.7262ccd3.js"><link rel="modulepreload" href="/mynotes/assets/_plugin-vue_export-helper.cdc0426e.js"><link rel="modulepreload" href="/mynotes/assets/面试.html.83fda80b.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/mynotes/" class="brand"><img class="logo" src="/mynotes/site_logo.png" alt="Zuooの学习笔记"><!----><span class="site-name hide-in-pad">Zuooの学习笔记</span></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/mynotes/quicknav/" class="nav-link" aria-label="快速导航"><span class="icon iconfont icon-navigation"></span>快速导航<!----></a></div><div class="nav-item hide-in-mobile"><a href="/mynotes/blog/" class="nav-link" aria-label="博客主页"><span class="icon iconfont icon-blog"></span>博客主页<!----></a></div><div class="nav-item hide-in-mobile"><a href="/mynotes/codenotes/" class="nav-link active" aria-label="代码笔记"><span class="icon iconfont icon-code"></span>代码笔记<!----></a></div><div class="nav-item hide-in-mobile"><a href="/mynotes/projects/" class="nav-link" aria-label="开源项目"><span class="icon iconfont icon-free"></span>开源项目<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="资源宝库"><span class="title"><span class="icon iconfont icon-advance"></span>资源宝库</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/mynotes/resources/books/" class="nav-link" aria-label="书籍资源"><span class="icon iconfont icon-animation"></span>书籍资源<!----></a></li><li class="dropdown-item"><a href="/mynotes/resources/videos/" class="nav-link" aria-label="影音资源"><span class="icon iconfont icon-play"></span>影音资源<!----></a></li></ul></button></div></div></nav><!--[--><!----><!--]--></div><div class="navbar-right"><!--[--><!----><!--]--><!----><div class="nav-item"><a class="repo-link" href="https://zqlyuchu.gitee.io/mynotes/" target="_blank" rel="noopener noreferrer" aria-label="Gitee"><svg xmlns="http://www.w3.org/2000/svg" class="icon source-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="source icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M601.92 475.2c0 76.428-8.91 83.754-28.512 99.594-14.652 11.88-43.956 14.058-78.012 16.434-18.81 1.386-40.392 2.97-62.172 6.534-18.612 2.97-36.432 9.306-53.064 17.424V299.772c37.818-21.978 63.36-62.766 63.36-109.692 0-69.894-56.826-126.72-126.72-126.72S190.08 120.186 190.08 190.08c0 46.926 25.542 87.714 63.36 109.692v414.216c-37.818 21.978-63.36 62.766-63.36 109.692 0 69.894 56.826 126.72 126.72 126.72s126.72-56.826 126.72-126.72c0-31.086-11.286-59.598-29.7-81.576 13.266-9.504 27.522-17.226 39.996-19.206 16.038-2.574 32.868-3.762 50.688-5.148 48.312-3.366 103.158-7.326 148.896-44.55 61.182-49.698 74.25-103.158 75.24-187.902V475.2h-126.72zM316.8 126.72c34.848 0 63.36 28.512 63.36 63.36s-28.512 63.36-63.36 63.36-63.36-28.512-63.36-63.36 28.512-63.36 63.36-63.36zm0 760.32c-34.848 0-63.36-28.512-63.36-63.36s28.512-63.36 63.36-63.36 63.36 28.512 63.36 63.36-28.512 63.36-63.36 63.36zM823.68 158.4h-95.04V63.36h-126.72v95.04h-95.04v126.72h95.04v95.04h126.72v-95.04h95.04z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button class="outlook-button" tabindex="-1" ariahidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索本站" autocomplete="off" spellcheck="false" value><!----></form><!--[--><!----><!--]--><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-java"></span><span class="title">Java核心</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-engine"></span><span class="title">Java虚拟机</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-frame"></span><span class="title">企业级框架</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-ability"></span><span class="title">算法和数据结构</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-mysql"></span><span class="title">数据库</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-computer"></span><span class="title">云计算</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-vue"></span><span class="title">web</span><span class="arrow right"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable active"><span class="icon iconfont icon-read"></span><span class="title">面试&amp;难点</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="面试题记录"><span class="icon iconfont icon-storage"></span>面试题记录<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_1-电商钱包" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.电商钱包"><!---->1.电商钱包<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_2-rpc协议" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.RPC协议"><!---->2.RPC协议<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_3-tcp三次握手四次挥手" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.TCP三次握手四次挥手"><!---->3.TCP三次握手四次挥手<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_4-autowired和resource注解的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.AutoWired和Resource注解的区别"><!---->4.AutoWired和Resource注解的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_5-tcp和udp区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.TCP和UDP区别"><!---->5.TCP和UDP区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_6-mysql的索引" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.MySQL的索引"><!---->6.MySQL的索引<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#聚簇索引和非聚簇索引" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="聚簇索引和非聚簇索引"><!---->聚簇索引和非聚簇索引<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_7-单例模式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7.单例模式"><!---->7.单例模式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_8-jvm有哪些区域" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="8.JVM有哪些区域"><!---->8.JVM有哪些区域<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_9-sleep和wait的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="9.sleep和wait的区别"><!---->9.sleep和wait的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_10-juc类知道哪些" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="10.JUC类知道哪些？"><!---->10.JUC类知道哪些？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_11-springboot如何实现自动装配" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="11.SpringBoot如何实现自动装配？"><!---->11.SpringBoot如何实现自动装配？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_12-bean的生命周期" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="12.Bean的生命周期"><!---->12.Bean的生命周期<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_13-redis有哪些数据类型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="13.Redis有哪些数据类型？"><!---->13.Redis有哪些数据类型？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_14-redis如何实现分布式锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="14.Redis如何实现分布式锁？"><!---->14.Redis如何实现分布式锁？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_15-hashmap底层原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="15.HashMap底层原理"><!---->15.HashMap底层原理<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_16-java的自动拆装箱" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="16.Java的自动拆装箱"><!---->16.Java的自动拆装箱<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_17-线程池使用-常用参数和创建方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="17.线程池使用？常用参数和创建方法"><!---->17.线程池使用？常用参数和创建方法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_18-常见排序算法时间复杂度" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="18.常见排序算法时间复杂度？"><!---->18.常见排序算法时间复杂度？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_19-collection和collections的作用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="19.Collection和Collections的作用"><!---->19.Collection和Collections的作用<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_20-gc垃圾回收算法了解多少" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="20.GC垃圾回收算法了解多少？"><!---->20.GC垃圾回收算法了解多少？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_21-mysql如何调优" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="21.Mysql如何调优？"><!---->21.Mysql如何调优？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_22-事务的底层原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="22.事务的底层原理？"><!---->22.事务的底层原理？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_23-讲讲java的锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="23.讲讲Java的锁"><!---->23.讲讲Java的锁<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_24-讲讲对ioc和aop的理解" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="24.讲讲对IOC和AOP的理解"><!---->24.讲讲对IOC和AOP的理解<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_25-redis为什么这么快-redis的io模型了解嘛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="25.Redis为什么这么快？Redis的IO模型了解嘛"><!---->25.Redis为什么这么快？Redis的IO模型了解嘛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_26-spring用到了哪些设计模式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="26.Spring用到了哪些设计模式"><!---->26.Spring用到了哪些设计模式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_27-有一张表-对a、b、c三个字段建立联合索引-问只对a、b-where查找-能命中吗" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="27.有一张表，对a、b、c三个字段建立联合索引，问只对a、b where查找，能命中吗？"><!---->27.有一张表，对a、b、c三个字段建立联合索引，问只对a、b where查找，能命中吗？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_28-mybatis中-和-的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="28.Mybatis中 # 和 $ 的区别"><!---->28.Mybatis中 # 和 $ 的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_29-restcontroller和-controller的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="29.@RestController和@Controller的区别"><!---->29.@RestController和@Controller的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_30-spring如何解决循环依赖" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="30.Spring如何解决循环依赖？"><!---->30.Spring如何解决循环依赖？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_31-将list转为string有几种方式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="31.将List转为String有几种方式？"><!---->31.将List转为String有几种方式？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_32-transactional注解的使用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="32.@Transactional注解的使用"><!---->32.@Transactional注解的使用<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_33-多态的应用场景" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="33.多态的应用场景"><!---->33.多态的应用场景<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_34-类加载机制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="34.类加载机制"><!---->34.类加载机制<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_35-gc什么时候触发-哪些可以作为gc-root-java-gc后还会有内存泄露的问题吗" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="35.GC什么时候触发？哪些可以作为GC root? Java GC后还会有内存泄露的问题吗？"><!---->35.GC什么时候触发？哪些可以作为GC root? Java GC后还会有内存泄露的问题吗？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_36-反射机制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="36. 反射机制"><!---->36. 反射机制<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_37-http和https的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="37.HTTP和HTTPS的区别？"><!---->37.HTTP和HTTPS的区别？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_38-多线程共享变量问题-threadlocal" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="38.多线程共享变量问题（ThreadLocal）"><!---->38.多线程共享变量问题（ThreadLocal）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_39-concurrenthashmap如何保证线程安全-分段锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="39.ConcurrentHashMap如何保证线程安全（分段锁）？"><!---->39.ConcurrentHashMap如何保证线程安全（分段锁）？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_40-讲讲cas和synchronized的区别、" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="40.讲讲CAS和Synchronized的区别、"><!---->40.讲讲CAS和Synchronized的区别、<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_41-为什么hashmap不用b树-为什么innodb索引不用红黑树" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="41.为什么HashMap不用B树？为什么InnoDB索引不用红黑树？"><!---->41.为什么HashMap不用B树？为什么InnoDB索引不用红黑树？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_42-如何保证分布式事务-分布式事务如何回滚" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="42.如何保证分布式事务？分布式事务如何回滚？"><!---->42.如何保证分布式事务？分布式事务如何回滚？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_43-讲讲threadlocal为什么会发生内存泄漏" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="43.讲讲ThreadLocal为什么会发生内存泄漏？"><!---->43.讲讲ThreadLocal为什么会发生内存泄漏？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_44-java序列化的理解-如何深拷贝" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="44.Java序列化的理解？如何深拷贝？"><!---->44.Java序列化的理解？如何深拷贝？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_50-mysql-的-count-如何优化" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="50.MySQL 的 count(*) 如何优化？"><!---->50.MySQL 的 count(*) 如何优化？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_51-mysql大规模数据的分页慢查询如何优化" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="51.MySQL大规模数据的分页慢查询如何优化？"><!---->51.MySQL大规模数据的分页慢查询如何优化？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_52-redis的过期删除策略和内存淘汰策略" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="52.Redis的过期删除策略和内存淘汰策略"><!---->52.Redis的过期删除策略和内存淘汰策略<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/mynotes/codenotes/work/%E5%88%86%E5%B8%83%E5%BC%8FID.html" class="nav-link sidebar-link sidebar-page" aria-label="分布式ID"><span class="icon iconfont icon-storage"></span>分布式ID<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/mynotes/codenotes/work/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.html" class="nav-link sidebar-link sidebar-page" aria-label="分布式事务"><span class="icon iconfont icon-storage"></span>分布式事务<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/mynotes/codenotes/work/MySQL%E8%87%AA%E5%A2%9EID%E8%B7%B3%E8%B7%83%E9%97%AE%E9%A2%98.html" class="nav-link sidebar-link sidebar-page" aria-label="MySQL自增ID跳跃问题"><span class="icon iconfont icon-storage"></span>MySQL自增ID跳跃问题<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-read"></span><span class="title">在线技术文档</span><span class="arrow right"></span></button><!----></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><span class="icon iconfont icon-storage"></span>面试题记录</h1><div class="page-info"><span class="category-info" aria-label="分类🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><ul class="categories-wrapper"><li><span class="category category2 clickable" role="navigation">面试</span></li></ul><meta property="articleSection" content="面试"></span><span aria-label="标签🏷" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="tag icon"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><ul class="tags-wrapper"><li><span class="tag tag8 clickable" role="navigation">面试题</span></li><li><span class="tag tag6 clickable" role="navigation">java</span></li><li><span class="tag tag2 clickable" role="navigation">后端</span></li></ul><meta property="keywords" content="面试题,java,后端"></span><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 41 分钟</span><meta property="timeRequired" content="PT41M"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_1-电商钱包" class="router-link-active router-link-exact-active toc-link level2">1.电商钱包</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_2-rpc协议" class="router-link-active router-link-exact-active toc-link level2">2.RPC协议</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_3-tcp三次握手四次挥手" class="router-link-active router-link-exact-active toc-link level2">3.TCP三次握手四次挥手</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_4-autowired和resource注解的区别" class="router-link-active router-link-exact-active toc-link level2">4.AutoWired和Resource注解的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_5-tcp和udp区别" class="router-link-active router-link-exact-active toc-link level2">5.TCP和UDP区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_6-mysql的索引" class="router-link-active router-link-exact-active toc-link level2">6.MySQL的索引</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#聚簇索引和非聚簇索引" class="router-link-active router-link-exact-active toc-link level3">聚簇索引和非聚簇索引</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_7-单例模式" class="router-link-active router-link-exact-active toc-link level2">7.单例模式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_8-jvm有哪些区域" class="router-link-active router-link-exact-active toc-link level2">8.JVM有哪些区域</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_9-sleep和wait的区别" class="router-link-active router-link-exact-active toc-link level2">9.sleep和wait的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_10-juc类知道哪些" class="router-link-active router-link-exact-active toc-link level2">10.JUC类知道哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_11-springboot如何实现自动装配" class="router-link-active router-link-exact-active toc-link level2">11.SpringBoot如何实现自动装配？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_12-bean的生命周期" class="router-link-active router-link-exact-active toc-link level2">12.Bean的生命周期</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_13-redis有哪些数据类型" class="router-link-active router-link-exact-active toc-link level2">13.Redis有哪些数据类型？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_14-redis如何实现分布式锁" class="router-link-active router-link-exact-active toc-link level2">14.Redis如何实现分布式锁？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_15-hashmap底层原理" class="router-link-active router-link-exact-active toc-link level2">15.HashMap底层原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_16-java的自动拆装箱" class="router-link-active router-link-exact-active toc-link level2">16.Java的自动拆装箱</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_17-线程池使用-常用参数和创建方法" class="router-link-active router-link-exact-active toc-link level2">17.线程池使用？常用参数和创建方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_18-常见排序算法时间复杂度" class="router-link-active router-link-exact-active toc-link level2">18.常见排序算法时间复杂度？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_19-collection和collections的作用" class="router-link-active router-link-exact-active toc-link level2">19.Collection和Collections的作用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_20-gc垃圾回收算法了解多少" class="router-link-active router-link-exact-active toc-link level2">20.GC垃圾回收算法了解多少？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_21-mysql如何调优" class="router-link-active router-link-exact-active toc-link level2">21.Mysql如何调优？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_22-事务的底层原理" class="router-link-active router-link-exact-active toc-link level2">22.事务的底层原理？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_23-讲讲java的锁" class="router-link-active router-link-exact-active toc-link level2">23.讲讲Java的锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_24-讲讲对ioc和aop的理解" class="router-link-active router-link-exact-active toc-link level2">24.讲讲对IOC和AOP的理解</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_25-redis为什么这么快-redis的io模型了解嘛" class="router-link-active router-link-exact-active toc-link level2">25.Redis为什么这么快？Redis的IO模型了解嘛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_26-spring用到了哪些设计模式" class="router-link-active router-link-exact-active toc-link level2">26.Spring用到了哪些设计模式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_27-有一张表-对a、b、c三个字段建立联合索引-问只对a、b-where查找-能命中吗" class="router-link-active router-link-exact-active toc-link level2">27.有一张表，对a、b、c三个字段建立联合索引，问只对a、b where查找，能命中吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_28-mybatis中-和-的区别" class="router-link-active router-link-exact-active toc-link level2">28.Mybatis中 # 和 $ 的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_29-restcontroller和-controller的区别" class="router-link-active router-link-exact-active toc-link level2">29.@RestController和@Controller的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_30-spring如何解决循环依赖" class="router-link-active router-link-exact-active toc-link level2">30.Spring如何解决循环依赖？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_31-将list转为string有几种方式" class="router-link-active router-link-exact-active toc-link level2">31.将List转为String有几种方式？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_32-transactional注解的使用" class="router-link-active router-link-exact-active toc-link level2">32.@Transactional注解的使用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_33-多态的应用场景" class="router-link-active router-link-exact-active toc-link level2">33.多态的应用场景</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_34-类加载机制" class="router-link-active router-link-exact-active toc-link level2">34.类加载机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_35-gc什么时候触发-哪些可以作为gc-root-java-gc后还会有内存泄露的问题吗" class="router-link-active router-link-exact-active toc-link level2">35.GC什么时候触发？哪些可以作为GC root? Java GC后还会有内存泄露的问题吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_36-反射机制" class="router-link-active router-link-exact-active toc-link level2">36. 反射机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_37-http和https的区别" class="router-link-active router-link-exact-active toc-link level2">37.HTTP和HTTPS的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_38-多线程共享变量问题-threadlocal" class="router-link-active router-link-exact-active toc-link level2">38.多线程共享变量问题（ThreadLocal）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_39-concurrenthashmap如何保证线程安全-分段锁" class="router-link-active router-link-exact-active toc-link level2">39.ConcurrentHashMap如何保证线程安全（分段锁）？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_40-讲讲cas和synchronized的区别、" class="router-link-active router-link-exact-active toc-link level2">40.讲讲CAS和Synchronized的区别、</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_41-为什么hashmap不用b树-为什么innodb索引不用红黑树" class="router-link-active router-link-exact-active toc-link level2">41.为什么HashMap不用B树？为什么InnoDB索引不用红黑树？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_42-如何保证分布式事务-分布式事务如何回滚" class="router-link-active router-link-exact-active toc-link level2">42.如何保证分布式事务？分布式事务如何回滚？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_43-讲讲threadlocal为什么会发生内存泄漏" class="router-link-active router-link-exact-active toc-link level2">43.讲讲ThreadLocal为什么会发生内存泄漏？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_44-java序列化的理解-如何深拷贝" class="router-link-active router-link-exact-active toc-link level2">44.Java序列化的理解？如何深拷贝？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_50-mysql-的-count-如何优化" class="router-link-active router-link-exact-active toc-link level2">50.MySQL 的 count(*) 如何优化？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_51-mysql大规模数据的分页慢查询如何优化" class="router-link-active router-link-exact-active toc-link level2">51.MySQL大规模数据的分页慢查询如何优化？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/mynotes/codenotes/work/%E9%9D%A2%E8%AF%95.html#_52-redis的过期删除策略和内存淘汰策略" class="router-link-active router-link-exact-active toc-link level2">52.Redis的过期删除策略和内存淘汰策略</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h2 id="_1-电商钱包" tabindex="-1"><a class="header-anchor" href="#_1-电商钱包" aria-hidden="true">#</a> 1.电商钱包</h2><p>业务背景：电商业务中，需要给电商app设计一个用户钱包，用户可以往钱包中充值，购买商品时用户可以使用钱包中的钱消费，商品申请退款成功后钱会退回钱包中，用户也可以申请提现把钱提到银行卡中</p><p>用程序实现如下api接口</p><ol><li><p>查询用户钱包余额</p></li><li><p>用户消费100元的接口</p></li><li><p>用户退款20元接口</p></li></ol><p>4查询用户钱包金额变动明细的接口</p><p>请给出建表语句和对应的代码（只要能实现上面api接口要求即可，不相关的表和代码不用写）</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> <span class="token identifier"><span class="token punctuation">`</span>user_wallet<span class="token punctuation">`</span></span><span class="token punctuation">;</span>
<span class="token keyword">create</span> <span class="token keyword">table</span> <span class="token identifier"><span class="token punctuation">`</span>user_wallet<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>
    <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">BIGINT</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">primary</span> <span class="token keyword">key</span> <span class="token keyword">auto_increment</span><span class="token punctuation">,</span>
	<span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span> <span class="token keyword">default</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">,</span>
    <span class="token identifier"><span class="token punctuation">`</span>amount<span class="token punctuation">`</span></span> <span class="token keyword">decimal</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;账户余额&#39;</span><span class="token punctuation">,</span>
    <span class="token identifier"><span class="token punctuation">`</span>pay_pwd<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> utf8mb4 <span class="token keyword">COLLATE</span> utf8mb4_0900_ai_ci<span class="token punctuation">,</span>
    <span class="token identifier"><span class="token punctuation">`</span>create_time<span class="token punctuation">`</span></span> <span class="token keyword">datetime</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;创建时间&#39;</span><span class="token punctuation">,</span>
  	<span class="token identifier"><span class="token punctuation">`</span>update_time<span class="token punctuation">`</span></span> <span class="token keyword">datetime</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;更新时间&#39;</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8mb4_0900_ai_ci<span class="token punctuation">;</span>

<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token identifier"><span class="token punctuation">`</span>user_wallet_record<span class="token punctuation">`</span></span><span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>user_wallet_record<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>
  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>user_id<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;钱包id&#39;</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>order_id<span class="token punctuation">`</span></span> <span class="token keyword">bigint</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;订单id&#39;</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>amount<span class="token punctuation">`</span></span> <span class="token keyword">decimal</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;金额&#39;</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>type<span class="token punctuation">`</span></span> <span class="token keyword">int</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;0-支出 1-退款 2-提现&#39;</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>bank_serial_number<span class="token punctuation">`</span></span> <span class="token keyword">int</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;银行流水号&#39;</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>update_time<span class="token punctuation">`</span></span> <span class="token keyword">datetime</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;更新时间&#39;</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">15</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4 <span class="token keyword">COLLATE</span><span class="token operator">=</span>utf8mb4_0900_ai_ci<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的sql查询代码：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 查询用户钱包余额</span>
<span class="token keyword">select</span> <span class="token identifier"><span class="token punctuation">`</span>amount<span class="token punctuation">`</span></span> <span class="token keyword">from</span> <span class="token identifier"><span class="token punctuation">`</span>user_wallet<span class="token punctuation">`</span></span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token comment">#{id};</span>

<span class="token comment">-- 用户消费100元的接口</span>
<span class="token comment">-- 1.生成订单</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token identifier"><span class="token punctuation">`</span>user_wallet_record<span class="token punctuation">`</span></span> <span class="token keyword">values</span><span class="token punctuation">(</span>
	<span class="token comment">#{user_id}, #{order_id}, 100, 0, #{bank_serial_number}, #{update_time}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">-- 2.减少账户余额</span>
<span class="token keyword">update</span> <span class="token identifier"><span class="token punctuation">`</span>user_wallet<span class="token punctuation">`</span></span> <span class="token keyword">set</span> <span class="token identifier"><span class="token punctuation">`</span>amount<span class="token punctuation">`</span></span> <span class="token operator">=</span> <span class="token identifier"><span class="token punctuation">`</span>amount<span class="token punctuation">`</span></span> <span class="token operator">-</span> <span class="token number">100</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token comment">#{id};</span>

<span class="token comment">-- 用户退款20元接口</span>
<span class="token comment">-- 1.生成订单</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token identifier"><span class="token punctuation">`</span>user_wallet_record<span class="token punctuation">`</span></span> <span class="token keyword">values</span><span class="token punctuation">(</span>
	<span class="token comment">#{user_id}, #{order_id}, 20, 1, #{bank_serial_number}, #{update_time}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">-- 2.增加</span>
<span class="token keyword">update</span> <span class="token identifier"><span class="token punctuation">`</span>user_wallet<span class="token punctuation">`</span></span> <span class="token keyword">set</span> <span class="token identifier"><span class="token punctuation">`</span>amount<span class="token punctuation">`</span></span> <span class="token operator">=</span> <span class="token identifier"><span class="token punctuation">`</span>amount<span class="token punctuation">`</span></span> <span class="token operator">+</span> <span class="token number">20</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token comment">#{id};</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-rpc协议" tabindex="-1"><a class="header-anchor" href="#_2-rpc协议" aria-hidden="true">#</a> 2.RPC协议</h2><p>RPC (Remote Procedure Call)即<strong>远程过程调用</strong>，是分布式系统常见的一种通信方法。</p><p>RPC需要解决的三个问题：</p><ul><li>Call ID映射——在RPC中，<strong>所有的函数都必须有自己的一个ID</strong>。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。</li><li>序列化和反序列化——需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。</li><li>网络传输——网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。</li></ul><p>主流的RPC框架：</p><ul><li>Thrift</li><li>Dubbo</li><li>SpringCloud</li></ul><p>RPC协议和HTTP协议区别：</p><p>RPC，可以基于TCP协议，也可以基于HTTP协议</p><p>RPC主要⽤于公司内部的服务调⽤，性能消耗低，传输效率⾼，服务治理⽅便。HTTP主要⽤于对外的异构环境，浏览器接⼝调⽤，APP接⼝调⽤，第三⽅接⼝调⽤等。</p><h2 id="_3-tcp三次握手四次挥手" tabindex="-1"><a class="header-anchor" href="#_3-tcp三次握手四次挥手" aria-hidden="true">#</a> 3.TCP三次握手四次挥手</h2><p>TCP 在传输之前会进行三次沟通，一般称为“三次握手”，传完数据断开的时候要进行四次沟通，一般称为“四次挥手”</p><ul><li>第一次握手：主机 A 发送数据包到主机 B，要求建立连接</li><li>第二次握手：主机 B 收到请求后要确认联机信息，向 A 发送数据包，表示让客户端确认是否能收到</li><li>第三次握手：主机 A 再次发送确认包(ACK)，表示确认收到服务器的包</li></ul><p>四次挥手：</p><ul><li>第一次挥手：客户端发送包，告诉服务器需要关闭连接，表示自己不用发送数据了，但是还可以接收数据</li><li>第二次挥手：服务端发送一个ACK的确认包，告诉客户端接收到关闭的请求，但是还没有准备好</li><li>第三次挥手：服务端准备好关闭连接时，发送FIN标记的包，告诉客户端准备关闭了</li><li>第四次挥手：客户端接收到服务端的关闭请求，再发送ACK标记的确认包，等待服务端可能请求重传的ACK包</li></ul><h2 id="_4-autowired和resource注解的区别" tabindex="-1"><a class="header-anchor" href="#_4-autowired和resource注解的区别" aria-hidden="true">#</a> 4.AutoWired和Resource注解的区别</h2><p>AutoWired注解是Spring的注解，只根据type注入bean，不会按照name匹配，如果有多个实现类，需要依赖@Qualifier或@Primary注解一起来修饰</p><p>Resource是Java的原生注解，支持按照name和type进行注入，默认按照name</p><h2 id="_5-tcp和udp区别" tabindex="-1"><a class="header-anchor" href="#_5-tcp和udp区别" aria-hidden="true">#</a> 5.TCP和UDP区别</h2><p>TCP/IP协议集包括应用层，传输层，网络层，网络访问层。</p><p>HTTP协议在应用层，IP协议属于网络层。</p><p>TCP（Transmission Control Protocol，传输控制协议）是<strong>面向连接</strong>的协议，也就是说，在收发数据前，必须和对方建立<strong>可靠</strong>的连接，面向字节流。（三次握手四次挥手）</p><p>UDP (User Data Protocol，用户数据报协议) 是一个<strong>非连接的协议</strong>，传输数据之前源端和终端<strong>不建立连接</strong>， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。UDP是不可靠的。面向数据报文。</p><h2 id="_6-mysql的索引" tabindex="-1"><a class="header-anchor" href="#_6-mysql的索引" aria-hidden="true">#</a> 6.MySQL的索引</h2><ul><li><p><strong>优缺点</strong></p><blockquote><p>能大大加快数据检索速度，但是需要占用一定的物理空间，而且创建和维护索引都需要花费时间</p></blockquote></li><li><p><strong>数据结构</strong></p><ol><li><p>B+树索引</p><blockquote><p>具有有序性，并且所有的数据都存放在叶子节点，所以查找的效率非常高，并且支持排序和范围查找。</p></blockquote></li><li><p>哈希索引</p><blockquote><p>基于哈希表实现，对于每一行数据，存储引擎会对索引列通过哈希算法进行哈希计算得到哈希码，查找一个数据的时间复杂度就是O(1)，一般多用于精确查找，不支持范围查找、模糊查询，可能有哈希冲突</p></blockquote></li></ol></li><li><p><strong>MySQL索引种类</strong></p><ul><li>主键索引【PRIMARY KEY】：数据列不允许重复，不能为NULL，一个表只能有一个主键索引</li><li>组合索引：由多个列值组成的索引</li><li>唯一索引【UNIQUE】：数据列不允许重复，可以为NULL,索引列的值必须唯一的，如果是组合索引，列值的组合必须唯一</li><li>全文索引【FULLTEXT KEY】：对文本的内容进行搜索</li><li>普通索引【INDEX】：基本的索引类型，可以为NULL</li></ul></li><li><h3 id="聚簇索引和非聚簇索引" tabindex="-1"><a class="header-anchor" href="#聚簇索引和非聚簇索引" aria-hidden="true">#</a> 聚簇索引和非聚簇索引</h3><p>最主要的区别是<strong>数据和索引是否分开存储</strong></p><ul><li>聚簇索引：将数据和索引放到一起存储，索引结构的叶子节点保留了数据行。</li><li>非聚簇索引：将数据进和索引分开存储，索引叶子节点存储的是指向数据行的地址。</li></ul></li><li><p><strong>如何创建索引</strong></p><p>1、<code>CREATE INDEX index_name ON table_name (column_list);</code></p><p>2、创建表时创建索引：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">table</span> <span class="token keyword">user</span><span class="token punctuation">(</span>
	id <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    information <span class="token keyword">text</span><span class="token punctuation">,</span>
    FULLTEXT <span class="token keyword">KEY</span><span class="token punctuation">(</span>infomation<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3、<code>ALTER TABLE table_name ADD INDEX index_name (column_list);</code></p><p>4、删除索引：<code>ALTER table table_name drop key index_name;</code></p><p>5、创建前缀索引：<code>ALTER TABLE table_name ADD key(column_name(prefix_length));</code></p></li></ul><h2 id="_7-单例模式" tabindex="-1"><a class="header-anchor" href="#_7-单例模式" aria-hidden="true">#</a> 7.单例模式</h2><p>它出现目的是为了保证一个类在系统中只有一个实例，并提供一个访问它的全局访问点。</p><p>应用场景：</p><p>1、有频繁实例化然后销毁的情况，也就是频繁的 new 对象，可以考虑单例模式；</p><p>2、创建对象时耗时过多或者耗资源过多，但又经常用到的对象；</p><p>3、频繁访问 IO 资源的对象，例如数据库连接池或访问本地文件。</p><p>例如网站在线人数计数器、配置文件的访问类、数据库连接池等。</p><p><strong>如何实现单例模式？</strong></p><ul><li><p>饿汉式（静态常量）</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token constant">INSTANCE</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>饿汉式（将类的实例化放在静态代码块）</p></li><li><p>枚举——可以避免多线程同步问题，还可以防止通过反射和反序列化来重新创建的对象</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token constant">INSTANCE</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">whateverMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将已有的类改造为单例类</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token punctuation">}</span>   
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">enum</span> <span class="token class-name">SingletonEnum</span> <span class="token punctuation">{</span>
        <span class="token constant">SINGLETON</span><span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token class-name">SingletonEnum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>双重检查</p></li></ul><p>下面是一个Jedis连接池工具类案例：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span></span><span class="token class-name">Jedis</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span></span><span class="token class-name">JedisPool</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span></span><span class="token class-name">JedisPoolConfig</span></span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * <span class="token keyword">@author</span> 左齐亮
 * <span class="token keyword">@version</span> 1.0
 * 使用连接池方式获取Redis连接
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JedisPoolUtil</span> <span class="token punctuation">{</span>
    <span class="token comment">// volatile作用：</span>
    <span class="token comment">// 1.线程可见性：当一个线程去修改一个共享变量时，其他线程立即得知改变</span>
    <span class="token comment">// 2.顺序的一致性；禁止指令重排</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">JedisPool</span> jedisPool <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token comment">//保证每次调用返回的是jedisPool是单例</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">JedisPool</span> <span class="token function">getJedisPoolInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> jedisPool<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">JedisPoolUtil</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> jedisPool<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment">//单例的双重校验</span>
                    <span class="token class-name">JedisPoolConfig</span> jedisPoolConfig <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPoolConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    jedisPoolConfig<span class="token punctuation">.</span><span class="token function">setMaxTotal</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    jedisPoolConfig<span class="token punctuation">.</span><span class="token function">setMaxIdle</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    jedisPoolConfig<span class="token punctuation">.</span><span class="token function">setMaxWaitMillis</span><span class="token punctuation">(</span><span class="token number">60</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    jedisPoolConfig<span class="token punctuation">.</span><span class="token function">setBlockWhenExhausted</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    jedisPoolConfig<span class="token punctuation">.</span><span class="token function">setTestOnBorrow</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    jedisPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPool</span><span class="token punctuation">(</span>jedisPoolConfig<span class="token punctuation">,</span> <span class="token string">&quot;192.168.50.132&quot;</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">,</span> <span class="token number">60000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> jedisPool<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//释放连接资源</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token class-name">Jedis</span> jedis<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span> jedis<span class="token punctuation">)</span> jedis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_8-jvm有哪些区域" tabindex="-1"><a class="header-anchor" href="#_8-jvm有哪些区域" aria-hidden="true">#</a> 8.JVM有哪些区域</h2><p>JVM内存区域主要分为线程私有区域、线程共享区域、直接内存</p><ul><li><p>线程私有区域：程序计数器、虚拟机栈、本地方法区，生命周期与线程相同</p></li><li><p>线程共享区：随虚拟机的启动/关闭而创建/销毁</p><p>分为<strong>方法区</strong>（<strong>永久代</strong>）和<strong>类实例区</strong>（java堆）</p><p>Java堆从GC的角度又分为<strong>新生代</strong>（eden、from survivor、to survivor）、<strong>老年代</strong></p><p>在Java8中，<code>永久代已经被移除，</code>被一个称为**“元数据区”<strong>（元空间）的区域所取代，元空间与永久代最大的区别就是不在虚拟机中，而是使用</strong>本地内存**。</p></li><li><p>直接内存：存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用</p></li></ul><h2 id="_9-sleep和wait的区别" tabindex="-1"><a class="header-anchor" href="#_9-sleep和wait的区别" aria-hidden="true">#</a> 9.sleep和wait的区别</h2><ul><li>sleep() 方法属于<strong>Thread</strong>类，而 wait() 方法属于<strong>Object</strong>类</li><li>sleep() 方法必须要传递一个超时时间的参数，参数时间内让出cpu给其他线程，但是<strong>不会释放对象锁</strong>，当指定的时间到了又会自动恢复运行状态，线程<strong>自动唤醒</strong></li><li>当调用wait() 方法的时候，线程会<strong>放弃对象锁</strong>，进入等待此对象的等待锁定池，只有针对此对象调用 <strong>notify()</strong> 方法或者 <strong>notifyAll()</strong> 后休眠的线程才能被唤醒</li><li>sleep可以在任何地方使用，而wait只能在同步方法或者同步块中使用，调用它的前提是当前线程占有锁，即<strong>必须配合 synchronized 一起使用</strong></li><li>它们都可以被 <strong>interrupted</strong> 方法中断</li></ul><h2 id="_10-juc类知道哪些" tabindex="-1"><a class="header-anchor" href="#_10-juc类知道哪些" aria-hidden="true">#</a> 10.JUC类知道哪些？</h2><ul><li><p>volatile</p><blockquote><p>volatile是Java提供的一种轻量级的同步机制</p><p>保证可见性</p><p>不保证原子性</p><p>禁止指令重排</p></blockquote><p>要保证原子性可以使用juc包下的 AutomicInteger、AutomicLong等</p></li><li><p>locks包</p><p>该包下有两个重要的接口Lock和ReadWriteLock(读写锁)，还有两个实现类ReentantLock、ReentrantReadWriteLock</p></li><li><p>一些线程安全的类</p><p>比如ArrayBlockingQueue、ConcurrentHashMap、DelayQueue、FutureTask、Semaphore、ThreadPoolExecutor</p></li></ul><h2 id="_11-springboot如何实现自动装配" tabindex="-1"><a class="header-anchor" href="#_11-springboot如何实现自动装配" aria-hidden="true">#</a> 11.SpringBoot如何实现自动装配？</h2><p><strong>SpringBoot启动流程：</strong></p><ul><li>首先从main找到run()方法，在执行run()方法之前new一个SpringApplication对象</li><li>进入run()方法，创建应用监听器SpringApplicationRunListeners开始监听</li><li>然后加载SpringBoot配置环境(ConfigurableEnvironment)，然后把配置环境(Environment)加入监听对象中</li><li>然后加载应用上下文(ConfigurableApplicationContext)，当做run方法的返回对象</li><li>最后创建Spring容器，refreshContext(context)，实现starter自动化配置和bean的实例化等工作。</li></ul><p><strong>SpringBoot自动装配：</strong></p><ul><li>@SpringBootApplication是复合注解，包含@EnableAutoConfiguration和@Configuration</li><li>@Configuration：被标注的类等于在Spring的XML配置文件中（applicationContext.xml)，装配所有bean事务，提供了一个Spring的上下文环境</li><li>@EnableAutoConfiguration会导入AutoConfigurationImportSelector这个类，这个类会利用SpringFactoriesLoader组件加载jar包里面<strong>META-INF/spring.factories</strong>配置文件里面填写的配置类，将这些配置类过滤一波后加载到Spring容器中</li></ul><h2 id="_12-bean的生命周期" tabindex="-1"><a class="header-anchor" href="#_12-bean的生命周期" aria-hidden="true">#</a> 12.Bean的生命周期</h2><h2 id="_13-redis有哪些数据类型" tabindex="-1"><a class="header-anchor" href="#_13-redis有哪些数据类型" aria-hidden="true">#</a> 13.Redis有哪些数据类型？</h2><ul><li><p><strong>string</strong></p><p>一个 Redis 中字符串 value 最多可以是 512M，<strong>特点：二进制安全，可以包含任何数据，包括图片或者序列化对象</strong></p></li><li><p><strong>hash</strong></p><p>一个键值对集合，hash 适合用于存储对象， 类似 Java 里面的Map&lt;String,Object&gt;</p></li><li><p><strong>list</strong></p><p>保存多个数据，底层使用双向链表存储结构。应用场景如：系统通知，按照时间顺序展示，将最近的通知列在前面</p></li><li><p><strong>set</strong></p><p>set 是可以自动排重的, 即值是<strong>不允许重复</strong>的</p></li><li><p><strong>zset(sorted_set)</strong></p><p>与 set 非常相似，是一个没有重复元素的字符串集合</p><p>不同之处是有序集合的每个成员都关联了一个评分(score),这个评分(score)被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以重复</p></li></ul><h2 id="_14-redis如何实现分布式锁" tabindex="-1"><a class="header-anchor" href="#_14-redis如何实现分布式锁" aria-hidden="true">#</a> 14.Redis如何实现分布式锁？</h2><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#setnx指令只能对不存在的键进行设置，可以用来设置锁</span>
<span class="token comment">#setnx lock value</span>
<span class="token comment">#一般同时设置锁的过期时间，防止死锁的同时保证两个操作的原子性</span>
<span class="token builtin class-name">set</span> lock val nx ex seconds
<span class="token comment">#删除锁</span>
del lock
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在使用RedisTemplate操作Redis时，删除锁的操作缺乏原子性，可以<strong>使用UUID作为锁的值</strong>，在释放锁时判断释放的锁是不是同一把锁，防止误删锁，进一步优化可以使用<strong>LUA脚本保证删除的原子性</strong></p><h2 id="_15-hashmap底层原理" tabindex="-1"><a class="header-anchor" href="#_15-hashmap底层原理" aria-hidden="true">#</a> 15.HashMap底层原理</h2><ul><li><p>HashMap底层使用数组+链表+红黑树</p></li><li><p>HashMap具有很快的访问速度，但是不能保证遍历顺序（LinkedHashMap增加了双向链表，可以保证遍历顺序）</p></li><li><p>HashMap 最多只允许一条记录的键为 null，允许多条记录的值为 null</p></li><li><p>HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能导致数据不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap</p></li><li><p>HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。每个结点 Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。</p><p>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。</p><p>loadFactor：负载因子，默认为 0.75。（这是时间和空间成本的折中）</p><p>threshold：扩容的阈值，等于 capacity * loadFactor</p><p>Java8引入了红黑树，当链表中的元素超过了 8 个以后， 会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)</p></li></ul><h2 id="_16-java的自动拆装箱" tabindex="-1"><a class="header-anchor" href="#_16-java的自动拆装箱" aria-hidden="true">#</a> 16.Java的自动拆装箱</h2><ul><li>装箱：把基本数据类型转换成包装类的过程</li><li>拆箱：把包装类转换成基本数据类型的过程</li></ul><p><strong>自动拆装箱的问题：</strong></p><ul><li>包装对象进行比较时，==比较的是地址，equals方法比较的是值</li><li>如果包装类对象为null，那么自动拆箱时就可能抛出空指针异常</li><li>如果在一个for循环中有大量的拆装箱操作，会浪费很多资源</li></ul><p><strong>缓存机制：</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Integer</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>      <span class="token comment">//整数3自动装箱</span>
        <span class="token class-name">Integer</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>      <span class="token comment">//整数3自动装箱</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//true</span>

        <span class="token class-name">Integer</span> c <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>    <span class="token comment">//整数128自动装箱</span>
        <span class="token class-name">Integer</span> d <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>    <span class="token comment">//整数128自动装箱</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c <span class="token operator">==</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//false</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从Java5开始提供了<strong>缓存机制</strong>——<strong>编译特性</strong>。Integer缓存数组中默认保存-128~127的值的包装类对象。其中后面的127数值可以通过<strong>JVM参数</strong> <code> -XX :AutoBoxCacheMax=size</code> 进行修改(JVM调优常用配置 )。这个参数只对Integer有效，Long无法调节。</p><p>缓存范围：</p><ul><li>Boolean：(全部缓存)</li><li>Byte：(全部缓存)</li><li>Character：(0 — 127缓存)</li><li>Short：(-128 — 127缓存)</li><li>Long：(-128 — 127缓存)</li><li>Integer：(-128 — 127缓存)</li><li>Float：(没有缓存)</li><li>Doulbe：(没有缓存)</li></ul><p>面试题1：java 是否存在使得语句 i &gt; j || i &lt;= j 结果为 false 的 i、j 值？</p><p>答：存在。java 的数值 NaN 代表 not a number，无法用于比较。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>i <span class="token operator">=</span> <span class="token class-name">Double<span class="token punctuation">.</span>NaN</span><span class="token punctuation">;</span>
j <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>面试题2：<code>Integer i=1; i += 1;</code>做了哪些事情？</p><p>答：首先<code>Integer i=1;</code>进行了自动装箱，使用 valueOf() 方法将 int 装箱成 Integer 类型；</p><p>接着 <code>i += 1;</code> 将 i 自动拆箱，完成加法运行后在进行装箱。</p><h2 id="_17-线程池使用-常用参数和创建方法" tabindex="-1"><a class="header-anchor" href="#_17-线程池使用-常用参数和创建方法" aria-hidden="true">#</a> 17.线程池使用？常用参数和创建方法</h2><p>线程池的优势：</p><ul><li>降低资源消耗</li><li>提高响应速度</li><li>提高线程的可管理性</li><li>提供更多更强大的功能，具备可拓展性。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行</li></ul><p>线程池的创建方法分为两类：</p><ul><li>通过 ThreadPoolExecutor 创建线程池</li><li>通过 Executors 创建的线程池</li></ul><p>具体创建方法分为7种：</p><ul><li>Executors.newFixedThreadPool：创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待；</li><li>Executors.newCachedThreadPool：创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程；</li><li>Executors.newSingleThreadExecutor：创建单个线程数的线程池，它可以保证先进先出的执行顺序；</li><li>Executors.newScheduledThreadPool：创建一个可以执行延迟任务的线程池</li><li>Executors.newSingleThreadScheduledExecutor：创建一个单线程的可以执行延迟任务的线程池；</li><li>Executors.newWorkStealingPool：创建一个抢占式执行的线程池（任务执行顺序不确定）【JDK 1.8 添加】。</li><li>ThreadPoolExecutor：最原始的创建线程池的方式，它包含了 7 个参数可供设置。</li></ul><p>如何选用？</p><p>Executors 返回的线程池对象弊端:</p><p>1） FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</p><p>2）CachedThreadPool：允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</p><p>推荐使用 ThreadPoolExecutor 的方式进行线程池的创建，因为这种创建方式更可控，并且更加明确了线程池的运行规则，可以规避一些未知的风险。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span> <span class="token comment">//核心线程数，始终存活的线程数</span>
                           <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span> <span class="token comment">//最大线程数</span>
                           <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span> <span class="token comment">//线程存活时间，线程中没有任务执行时最大线程就会销毁一部分</span>
                           <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span> <span class="token comment">//配合keepAliveTime使用，时间单位</span>
                           <span class="token comment">//阻塞队列，存储线程池等待执行的任务，线程安全</span>
                           <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span>
                           <span class="token comment">//线程工厂，主要用来创建线程，默认为正常优先级、非守护线程</span>
                           <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span>
                           <span class="token comment">//拒绝策略</span>
                           <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 省略...</span>
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>阻塞队列选用</p><p>比较常用的是 <code>LinkedBlockingQueue</code> 和 <code>SynchronousQueue</code></p></li><li><p>拒绝策略选用</p><blockquote><p>包括以下四种：</p><p>1、AbortPolicy：拒绝并抛出异常</p><p>2、CallerRunsPolicy：使用当前调用的线程来执行任务</p><p>3、DiscardOldestPolicy：抛弃队列头部（最旧）的一个任务，并执行当前任务</p><p>4、DiscardPolicy：忽略并抛弃当前任务</p><p>默认是<code>AbortPolicy</code>，支持自定义</p></blockquote></li></ul><h2 id="_18-常见排序算法时间复杂度" tabindex="-1"><a class="header-anchor" href="#_18-常见排序算法时间复杂度" aria-hidden="true">#</a> 18.常见排序算法时间复杂度？</h2><h2 id="_19-collection和collections的作用" tabindex="-1"><a class="header-anchor" href="#_19-collection和collections的作用" aria-hidden="true">#</a> 19.Collection和Collections的作用</h2><ul><li>java.util.Collection 是一个集合框架的父接口，Set、List 都实现了该接口，提供了对集合对象进行基本操作的通用接口方法</li><li>Collections 是一个包装类，包含各种有关集合操作的静态方法，包含对集合的排序、搜索以及序列化等。不能实例化，是一个工具类</li></ul><h2 id="_20-gc垃圾回收算法了解多少" tabindex="-1"><a class="header-anchor" href="#_20-gc垃圾回收算法了解多少" aria-hidden="true">#</a> 20.GC垃圾回收算法了解多少？</h2><p>GC最基础的算法有三种： 标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。</p><ul><li>标记 -清除算法，“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。</li><li>复制算法，“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</li><li>标记-压缩算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清 理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存分代收集算法，</li><li>分代收集（Generational Collection）算法，把Java堆分为新生代和老年代，这 样就可以根据各个年代的特点采用最适当的收集算法。</li></ul><h2 id="_21-mysql如何调优" tabindex="-1"><a class="header-anchor" href="#_21-mysql如何调优" aria-hidden="true">#</a> 21.Mysql如何调优？</h2><ul><li>1、查询语句中不要使用select *</li><li>2、尽量减少子查询，使用关联查询（left join,right join,inner join）替代</li><li>3、减少使用IN或者NOT IN ,使用exists，not exists或者关联查询语句替代</li><li>4、or 的查询尽量用 union或者union all 代替(在确认没有重复数据或者不用剔除重复数据时，union all会更好)</li><li>5、应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</li><li>6、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫 描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null 值，然后这样查询： select id from t where num=0</li></ul><h2 id="_22-事务的底层原理" tabindex="-1"><a class="header-anchor" href="#_22-事务的底层原理" aria-hidden="true">#</a> 22.事务的底层原理？</h2><h2 id="_23-讲讲java的锁" tabindex="-1"><a class="header-anchor" href="#_23-讲讲java的锁" aria-hidden="true">#</a> 23.讲讲Java的锁</h2><p><a href="https://blog.csdn.net/java_cch/article/details/118381485" target="_blank" rel="noopener noreferrer">java锁面试<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>Java中锁的实现方式有两种，synchronized关键字和并发包中的锁类。</p><p>几种关于锁的概念：</p><ul><li>死锁：线程之间相互等待着对方释放资源，而自己的资源又不释放</li><li>重入锁：一个线程在拥有了当前资源的锁之后，可以再次拿到锁而不被阻塞</li><li>自旋锁：</li><li>自适应自旋锁：</li></ul><h2 id="_24-讲讲对ioc和aop的理解" tabindex="-1"><a class="header-anchor" href="#_24-讲讲对ioc和aop的理解" aria-hidden="true">#</a> 24.讲讲对IOC和AOP的理解</h2><ul><li><p>IOC就是Spring提供的一种容器管理技术，通过依赖注入的方式使编程时无需手动实例化，我们可以使用核心注解@Autowired和@Resource进行自动装配，还可以使用@Value注解注入属性值</p></li><li><p>AOP是面向切面编程，简单地说就是可以在方法执行前后使用动态代理技术加上需要的逻辑。如果实现了接口，Spring会使用JDK的动态代理，否则使用CGLib动态代理。常用场景包括权限认证、自动缓存、错误处理、日志、调试和事务等。</p><p>AOP的相关注解有：</p><blockquote><p>@Aspect：声明被注解的类是一个切面Bean</p><p>@Before：前置通知</p><p>@After：后置通知（不论正常返回还是异常退出）</p><p>@AfterReturnning：返回后通知，正常完成后执行的通知，返回值使用returnning属性接收</p><p>@AfterThrowing：异常通知，异常使用throwing属性接收</p></blockquote></li></ul><p>参考原文：<a href="https://blog.csdn.net/weixin_48182198/article/details/107593961" target="_blank" rel="noopener noreferrer">面试必问的Spring IoC与Spring AOP面试题<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="_25-redis为什么这么快-redis的io模型了解嘛" tabindex="-1"><a class="header-anchor" href="#_25-redis为什么这么快-redis的io模型了解嘛" aria-hidden="true">#</a> 25.Redis为什么这么快？Redis的IO模型了解嘛</h2><p>Redis的QPS可达到10万/每秒，共有以下五点原因：</p><ul><li><p>基于内存实现——对比MySQL磁盘数据库</p></li><li><p>高效的数据结构</p></li><li><p>使用了合理的数据编码</p></li><li><p>合理的线程模型</p><p>Redis是单线程模型，有效避免了上下文的切换，同时使用了IO多路复用技术</p></li><li><p>虚拟内存机制</p><p>暂时把冷数据放到磁盘，从而腾出了宝贵的内存空间，通过VM机制实现了冷热数据分离，避免因为内存不足而造成访问速度下降</p></li></ul><p>Redis的I/O多路复用模型有效地解决了单线程的服务端，使用不阻塞的方式处理多个client端请求问题。</p><p>多路指的是多个网络连接客户端，这个模型使用了一个线程检查多个Socket的就绪状态，从而管理多个IO流，</p><h2 id="_26-spring用到了哪些设计模式" tabindex="-1"><a class="header-anchor" href="#_26-spring用到了哪些设计模式" aria-hidden="true">#</a> 26.Spring用到了哪些设计模式</h2><ul><li>控制翻转（IoC原则）和 <strong>依赖注入</strong>（Dependcy Inject)</li><li><strong>工厂设计模式</strong>：Spring使用工厂模式可以通过 <code>BeanFactory</code> 或 <code>ApplicationContext</code> 创建 bean 对象</li><li><strong>单例设计模式</strong>：Spring 中 bean 的默认作用域就是 <strong>singleton</strong>(单例)的</li><li><strong>代理设计模式</strong>：AOP切面编程就是基于<strong>动态代理</strong>的</li><li><strong>模板方法模式</strong>：是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。例如JDBCTemplate。</li><li><strong>观察者模式</strong>：是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。Spring <strong>事件驱动模型</strong>就是观察者模式很经典的一个应用。</li><li><strong>适配器模式</strong>：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。</li><li><strong>装饰器模式</strong>：可以动态地给对象添加一些额外的属性或行为。相比于使用继承，装饰者模式更加灵活。</li></ul><h2 id="_27-有一张表-对a、b、c三个字段建立联合索引-问只对a、b-where查找-能命中吗" tabindex="-1"><a class="header-anchor" href="#_27-有一张表-对a、b、c三个字段建立联合索引-问只对a、b-where查找-能命中吗" aria-hidden="true">#</a> 27.有一张表，对a、b、c三个字段建立联合索引，问只对a、b where查找，能命中吗？</h2><p>mysql 建立多列索引（联合索引）有<strong>最左前缀</strong>的原则，即<strong>最左优先</strong>，如：</p><ul><li>如果有一个 2 列的索引 (col1, col2)，则已经对 (col1)、(col1, col2) 上建立了索引；</li><li>如果有一个 3 列索引 (col1, col2, col3)，则已经对 (col1)、(col1, col2)、(col1, col2, col3) 上建立了索引；</li></ul><p><code>select * from [table] where A = 1 and B = 3</code></p><p>上面这个sql语句执行后，数据库系统可以直接从索引文件中直接二分法找到 A = 1 的记录，然后再 B = 3 的记录</p><p>但如果是 where B = 3 则需要遍历这个索引表的全部</p><p>注意：</p><ul><li>如果查询条件中含有函数或者表达式，将导致索引失效而进行全表查询</li><li>如果查询条件中有两个范围列则无法全用到索引</li><li>like &quot;value%&quot;可以使用索引，like &quot;%value%&quot; 不会使用索引，走的是全表扫描</li><li>索引不会包含NULL值的列，联合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的</li></ul><h2 id="_28-mybatis中-和-的区别" tabindex="-1"><a class="header-anchor" href="#_28-mybatis中-和-的区别" aria-hidden="true">#</a> 28.Mybatis中 # 和 $ 的区别</h2><ul><li><p>使用#{}的方式可以很大程度防止sql注入，而 ${} 无法防止sql注入</p></li><li><p>使用${}会将传入的数据直接显示生成在sql中，而#{}将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。所以在JDBC能使用占位符的地方，最好优先使用#{}，否则用${}</p><p>典型情况就是<strong>动态参数</strong></p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code>-- 动态指定表名
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span><span class="token punctuation">&gt;</span></span>
      select *  from emp_ ${year}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>

-- 排序时使用 order by动态参数
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span><span class="token punctuation">&gt;</span></span>
       select  *  from dept order by ${name}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>模糊查询</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>findUserByName<span class="token punctuation">&quot;</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>String<span class="token punctuation">&quot;</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>studentResultMap<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
        SELECT * FROM user WHERE username LIKE &#39;%${value}%&#39;
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>findUserByName<span class="token punctuation">&quot;</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>String<span class="token punctuation">&quot;</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>studentResultMap<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
        SELECT * FROM USER WHERE username LIKE CONCAT(&#39;%&#39;, #{username}, &#39;%&#39;)
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h2 id="_29-restcontroller和-controller的区别" tabindex="-1"><a class="header-anchor" href="#_29-restcontroller和-controller的区别" aria-hidden="true">#</a> 29.@RestController和@Controller的区别</h2><p>@RestController注解等价于@ResponseBody ＋ @Controller</p><ul><li><strong>共同点</strong>：都用来表示Spring某个类是否可以接收HTTP请求</li><li><strong>二者区别： @RestController无法返回指定页面，而@Controller可以</strong>；如果需要返回JSON，XML或自定义mediaType内容到页面，@RestController自己就可以搞定，这个注解对于返回数据比较方便，因为它<strong>会自动将对象实体转换为JSON格式</strong>。而@Controller需要在对应的方法加上@ResponseBody注解。</li></ul><h2 id="_30-spring如何解决循环依赖" tabindex="-1"><a class="header-anchor" href="#_30-spring如何解决循环依赖" aria-hidden="true">#</a> 30.Spring如何解决循环依赖？</h2><p><a href="https://blog.csdn.net/Candyz7/article/details/126776789?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~AD_ESQUERY~yljh-2-126776789-blog-119222944.pc_relevant_aa&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~AD_ESQUERY~yljh-2-126776789-blog-119222944.pc_relevant_aa&amp;utm_relevant_index=3" target="_blank" rel="noopener noreferrer">什么是Spring的循环依赖<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="_31-将list转为string有几种方式" tabindex="-1"><a class="header-anchor" href="#_31-将list转为string有几种方式" aria-hidden="true">#</a> 31.将List转为String有几种方式？</h2><ul><li>循环遍历List进行字符串拼接</li><li>利用join方法：String.join(&quot;,&quot; , list);</li><li>利用StringUtils的join方法：StringUtils.join(list, &quot;,&quot;);</li><li>利用stream流：list.stream().collect(Collectors.joining(&quot;,&quot;));</li></ul><h2 id="_32-transactional注解的使用" tabindex="-1"><a class="header-anchor" href="#_32-transactional注解的使用" aria-hidden="true">#</a> 32.@Transactional注解的使用</h2><ul><li><p>该注解只能用在public 方法上，如果用在protected或者private的方法上，不会报错，但是该注解不会生效</p></li><li><p>只能回滚非检查型异常，具体为RuntimeException及其子类和Error子类</p></li><li><p>使用rollbackFor 属性来定义回滚的异常类型，使用 propagation 属性定义事务的传播行为</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> <span class="token class-name">Exception</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span><span class="token constant">REQUIRED</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>不能回滚被try{}catch() 捕获的异常</p></li><li><p>只能对在被Spring 容器扫描到的类下的方法生效</p></li></ul><p><strong>事务传播规则：</strong></p><table><thead><tr><th>PROPAGATION_REQUIRED</th><th>支持当前事务，如果当前没有事务，则创建一个事务，这是最常见的选择</th></tr></thead><tbody><tr><td><strong>PROPAGATION_SUPPORTS</strong></td><td><strong>支持当前事务，如果当前没有事务，就以非事务来执行</strong></td></tr><tr><td><strong>PROPAGATION_MANDATORY</strong></td><td><strong>支持当前事务，如果没有当前事务，就抛出异常</strong></td></tr><tr><td><strong>PROPAGATION_REQUIRES_NEW</strong></td><td><strong>新建事务，如果当前存在事务，就把当前事务挂起</strong></td></tr><tr><td><strong>PROPAGATION_NOT_SUPPORTED</strong></td><td><strong>以非事务执行操作，如果当前存在事务，则当前事务挂起</strong></td></tr><tr><td><strong>PROPAGATION_NEVER</strong></td><td><strong>以非事务方式执行，如果当前存在事务，则抛出异常</strong></td></tr><tr><td><strong>PROPAGATION_NESTED</strong></td><td><strong>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED 类似的操作。</strong></td></tr></tbody></table><p>事务隔离级别，使用isolation属性进行配置：</p><ul><li>Isolation.READ_UNCOMMITTED：读取未提交数据(会出现脏读, 不可重复读) 基本不使用</li><li>Isolation.READ_COMMITTED：读取已提交数据(会出现不可重复读和幻读)</li><li>Isolation.REPEATABLE_READ：可重复读(会出现幻读)</li><li>Isolation.SERIALIZABLE：串行化</li></ul><p>MySQL默认使用的隔离级别为REPEATABLE_READ</p><h2 id="_33-多态的应用场景" tabindex="-1"><a class="header-anchor" href="#_33-多态的应用场景" aria-hidden="true">#</a> 33.多态的应用场景</h2><p>多态——把子类对象伪装成父类对象</p><ul><li>定义方法参数列表时，定义为父类类型，这样就可以传递任意子类类型的对象</li><li>定义成员变量时，定义为父类类型，这样就可以赋值任意子类类型的对象</li><li>定义方法返回值类型时，定义为父类类型，这样就可以返回任意子类类型的对象</li><li>定义数组元素类型时，定义为父类类型，这样就可以装任意子类类型的对象</li></ul><p>好处：</p><ul><li>增强了代码的复用性</li><li>增强了类的扩展性</li><li>降低了耦合性</li></ul><h2 id="_34-类加载机制" tabindex="-1"><a class="header-anchor" href="#_34-类加载机制" aria-hidden="true">#</a> 34.类加载机制</h2><p><a href="https://www.cnblogs.com/chanshuyi/p/the_java_class_load_mechamism.html" target="_blank" rel="noopener noreferrer">两道面试题，带你解析Java类加载机制 - 陈树义 - 博客园 (cnblogs.com)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>类加载过程主要包含加载、验证、准备、解析、初始化、使用、卸载七个方面</p><h2 id="_35-gc什么时候触发-哪些可以作为gc-root-java-gc后还会有内存泄露的问题吗" tabindex="-1"><a class="header-anchor" href="#_35-gc什么时候触发-哪些可以作为gc-root-java-gc后还会有内存泄露的问题吗" aria-hidden="true">#</a> 35.GC什么时候触发？哪些可以作为GC root? Java GC后还会有内存泄露的问题吗？</h2><ul><li>GC分为 minor GC 和 Full GC</li><li>Java堆从GC的角度又分为<strong>新生代</strong>（eden、from survivor、to survivor）、<strong>老年代</strong>(在Java8中，<code>永久代已经被移除，</code>被一个称为**“元数据区”**（元空间）的区域所取代)</li></ul><!----><p>1、在程序空闲时。</p><p>2、程序不可预知的时候/手动调用 System.gc() 。不要手动调用GC，不管是 JVM 自己调用还是手动调用都会使系统陷入短暂的停顿，给垃圾回收让路，手动调用就违背了我们优化 GC 的初衷了</p><p>3、堆内存不足时 GC 会被调用。当应用线程在运行，并在运行过程中穿件对象，若这时内存空间不足，JVM就会强制的调用 GC ，一遍回收内存用于新的分配。若GC 一次之后仍不满足内存分配的要求，JVM会再次进行两次 GC 做进一步尝试，若还是不满足需求则会抛出 “out of memort” 的错误使应用异常停止</p><blockquote><p>轻GC的触发条件：多数情况下，直接在 Eden 区中进行分配。如果 Eden区域没有足够的空间，那么就会发起一次 Minor GC</p><p>重GC的触发条件：如果老年代没有足够空间的话，那么就会进行一次 Full GC</p></blockquote><!----><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>
​	1、静态集合类，如 HashMap、Vector 等，因为GC是不会回收静态类的
​    2、各种连接，如 数据库连接、网络连接、IO连接等如果没有调用 close 关闭，GC不会回收导致的内存泄露，所以我们一再强调使用完连接之后一定要在  finally 中关闭
​    3、强引用，Object obj = new Object()  这种使用 new 方式创建的就属于强引用，（如果有GCRoots的强引用）垃圾回收器绝对不会回收它，当内存不足时宁愿抛出 OOM 错误使得程序异常停止也不会回收强引用对象
​    4、监听器的使用，在释放内存的同时没有相应删除监听器的时候也可能导致内存泄露

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><!----><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> - 可达性分析（Java中使用）
这个算法的基本思路就是通过一系列的称为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GCRoots没有任何引用链相连时，则证明此对象是不可用的。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><!----><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>当前虚拟机栈中局部变量表中的引用对象
当前本地方法栈中局部变量中的引用的对象
方法区中类静态属性引用的对象
方法区中常量引用的对象
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_36-反射机制" tabindex="-1"><a class="header-anchor" href="#_36-反射机制" aria-hidden="true">#</a> 36. 反射机制</h2><h2 id="_37-http和https的区别" tabindex="-1"><a class="header-anchor" href="#_37-http和https的区别" aria-hidden="true">#</a> 37.HTTP和HTTPS的区别？</h2><ul><li>HTTPS 协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。</li><li>HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 <strong>SSL 加密传输协议</strong>。</li><li>HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</li></ul><h2 id="_38-多线程共享变量问题-threadlocal" tabindex="-1"><a class="header-anchor" href="#_38-多线程共享变量问题-threadlocal" aria-hidden="true">#</a> 38.多线程共享变量问题（ThreadLocal）</h2><ul><li><p><strong>volatile</strong>变量每次被线程访问时，都强迫线程从主内存中重读该变量的最新值，而当该变量发生修改变化时，也会强迫线程将最新的值刷新回主内存中。这样一来，不同的线程都能及时的看到该变量的最新值。但是volatile<strong>不能保证变量更改的原子性</strong></p><p>适用于：</p><ul><li>对变量的写入操作不依赖当前值</li><li>当前volatile变量不依赖于别的volatile变量</li></ul></li><li><p>对自增之类的非原子性操作想要保证可见性，可以使用</p><p>1、加锁：synchronized或者ReentantLock</p><p>2、使用原子类：AtomicInteger</p></li><li><p><strong>ThreadLoacl</strong></p><p>参考：<a href="https://blog.csdn.net/abc123mma/article/details/128060530" target="_blank" rel="noopener noreferrer">Java并发-ThreadLocal的使用<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><blockquote><p>1、当使用 ThreadLocal 维护变量时，ThreadLocal 为每个使用该变量的线程提供<strong>独立的变量副本</strong>，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。可以避免线程安全问题。</p><p>2、ThreadLocal 是线程本地存储，在每个线程中都创建了一个 <strong>ThreadLocalMap</strong> 对象，每个线程可以访问自己内部 ThreadLocalMap 对象内的 value。通过这种方式，避免资源在多线程间共享</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> local <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 
        <span class="token class-name">Thread</span> threadA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>
            local<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;线程One-在里面设置值了&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>local<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        threadA<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">&quot;ThreadOne&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token class-name">Thread</span> threadB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>
            local<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;线程Two-在里面设置值了&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>local<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            local<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        threadB<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">&quot;ThreadTwo&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        threadA<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        threadB<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>threadA调用set方法并休眠5秒后进行打印变量值，threadB调用set方法立即打印并且remove。最终结果两个线程没有互相干涉，都正常输出。</p><p>缺点：ThreadLocal维护的变量<strong>只能设置一个值，再次调用set方法时会覆盖</strong>。</p></li></ul><h2 id="_39-concurrenthashmap如何保证线程安全-分段锁" tabindex="-1"><a class="header-anchor" href="#_39-concurrenthashmap如何保证线程安全-分段锁" aria-hidden="true">#</a> 39.ConcurrentHashMap如何保证线程安全（分段锁）？</h2><ul><li>底层采用分段的数组+链表实现，<strong>线程安全</strong></li><li>通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。(读操作不加锁，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。)</li><li>Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术</li><li>有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁</li><li>扩容：段内扩容（段内元素超过该段对应Entry数组长度的75%触发扩容，不会对整个Map进行扩容），插入前检测需不需要扩容，有效避免无效扩容</li></ul><p><strong>锁分段技术</strong>：首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p><p>ConcurrentHashMap默认将hash表分为16个桶，诸如get、put、remove等常用操作只锁住当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有16个写线程执行，并发性能的提升是显而易见的。</p><h2 id="_40-讲讲cas和synchronized的区别、" tabindex="-1"><a class="header-anchor" href="#_40-讲讲cas和synchronized的区别、" aria-hidden="true">#</a> 40.讲讲CAS和Synchronized的区别、</h2><p>参考：<a href="https://zhuanlan.zhihu.com/p/134085332" target="_blank" rel="noopener noreferrer">面试被问CAS和Synchronized的区别<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>CAS（Compare And Swap ）是乐观锁的一种实现方式，是一种<mark>轻量级锁</mark>。JAVA1.5开始引入了CAS，JUC下很多工具类都是基于CAS。</p><p>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。当多个线程同时尝试使用CAS更新一个变量时，任何时候只有一个线程可以更新成功，若更新失败，线程会重新进入循环再次进行尝试。</p><p>CAS在Java中的应用：</p><p>主要依赖于<strong>Unsafe</strong>的CAS操作来进行实现，可能会出现自旋问题，CPU压力很大，可以使用版本号机制解决ABA问题</p><p>相比于CAS基于乐观锁实现，**synchronized **是基于<mark>悲观锁</mark>的，当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</p><h2 id="_41-为什么hashmap不用b树-为什么innodb索引不用红黑树" tabindex="-1"><a class="header-anchor" href="#_41-为什么hashmap不用b树-为什么innodb索引不用红黑树" aria-hidden="true">#</a> 41.为什么HashMap不用B树？为什么InnoDB索引不用红黑树？</h2><p>HashMap 如果用B/B+树的话，在数据量不是很多的情况下，数据都会“挤在”一个结点里面，这个时候遍历效率就退化成了链表。</p><p><a href="https://zhuanlan.zhihu.com/p/54102723" target="_blank" rel="noopener noreferrer">漫画：什么是B+树？ - 知乎 (zhihu.com)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>B树是一种磁盘友好型的数据结构，树的高度是可控的，一般比较矮胖，树的高度可以大致上看成磁盘IO的次数，</p><p>B+树也是一种平衡树，但是它的叉是可动态指定的，在Mysql中大约是1170。因为叉的数量足够多，所以在同等数量级下，树高更低。通过增加单个节点中关键字的数量，来降低树高，这种结构更适合磁盘。</p><p><strong>B+树的优势：</strong></p><p>1.单一节点存储更多的元素，使得查询的IO次数更少。</p><p>2.所有查询都要查找到叶子节点，查询性能稳定。</p><p>3.所有叶子节点形成有序链表，便于范围查询。</p><h2 id="_42-如何保证分布式事务-分布式事务如何回滚" tabindex="-1"><a class="header-anchor" href="#_42-如何保证分布式事务-分布式事务如何回滚" aria-hidden="true">#</a> 42.如何保证分布式事务？分布式事务如何回滚？</h2><p>事务的ACID特性：</p><ul><li>原子性(Atomicity)：操作过程不可分割,要么都成功，要么都失败</li><li>一致性(Consistency)：指在数据库操作前后是完全一致的。这个一致可以理解为对数据库操作的有效性</li><li>隔离性(Isolation)：多个事物可以同时进行且彼此之间无法访问。只有在事物完成最终的操作的时候，才可以看见结果。这种主要涉及到数据的脏读，幻读等问题。</li><li>持久性(Durability)：已被提交的事务对数据库的修改应该永久保存在数据库中</li></ul><p>事务的隔离级别：</p><table><thead><tr><th>隔离级别</th><th>值</th><th>导致的问题</th></tr></thead><tbody><tr><td>Read-Uncommited</td><td>0</td><td>导致脏读</td></tr><tr><td>Read-Commited</td><td>1</td><td>避免脏读，允许不可重复读和幻读</td></tr><tr><td>Repeatable-Read</td><td>2</td><td>MySQL默认隔离级别。避免脏读和不可重复读，允许幻读</td></tr><tr><td>Serializable</td><td>3</td><td>串行化读，事务只能一个一个地执行，但是执行效率较慢，慎重使用</td></tr></tbody></table><ul><li>脏读（Read Uncommited）：读到了其他事务未提交的数据</li><li>不可重复读（Non-repeatable Read）：多次查询到的数据不一致，读取到的是已提交的数据</li><li>幻读（Phantom Read）：指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录 时，会产生幻行。幻读只能通过Serializable隔离级别来实现</li></ul><p><a href="https://blog.csdn.net/weixin_48272905/article/details/108525283" target="_blank" rel="noopener noreferrer">Spring事务和MySQL事务<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><a href="https://blog.csdn.net/Huang_ZX_259/article/details/128375673" target="_blank" rel="noopener noreferrer">如何保证分布式事务<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="_43-讲讲threadlocal为什么会发生内存泄漏" tabindex="-1"><a class="header-anchor" href="#_43-讲讲threadlocal为什么会发生内存泄漏" aria-hidden="true">#</a> 43.讲讲ThreadLocal为什么会发生内存泄漏？</h2><p>在每一个线程Thread对象中，都维护了一个<strong>ThreadLocalMap</strong> 对象</p><p><strong>ThreaLocal本身是不存储值的，我们在使用其对应的set、get方法时，都是操作的其对应的ThreadLocalMap对象</strong></p><p>在ThreadLocalMap的Entry中的<strong>key</strong>存储的是ThreadLocal的<strong>弱引用</strong>，<strong>value</strong>存储的是对象的<strong>强引用</strong></p><p><strong>弱引用在发生GC时，就会被垃圾回收掉</strong></p><p>所以，在当前线程正在运行的时候，发生GC时，在ThreadLocal对象没有被其它地方强引用时，key指向ThreadLocal的虚引用就会立即断开（被垃圾回收掉），这时，就会出现ThreadLocalMap中存在key为null的Entry，只要当前线程不结束，该ThreadLocalMap对象就会一直存在，永远无法回收，因为此时还存在一条强引用的链路</p><p><strong>Entry对象的key为什么要使用弱引用，有什么好处？</strong></p><p>假设如果存储的强引用，将ThreadLocal置为空，那我们断开ThreadLocal Reference —&gt; ThreadLocal的引用，会发现key强引用了ThreadLocal，导致该对象永远无法被GC。</p><h2 id="_44-java序列化的理解-如何深拷贝" tabindex="-1"><a class="header-anchor" href="#_44-java序列化的理解-如何深拷贝" aria-hidden="true">#</a> 44.Java序列化的理解？如何深拷贝？</h2><p><a href="https://zhuanlan.zhihu.com/p/340258358" target="_blank" rel="noopener noreferrer">面试官：Java序列化为什么要实现Serializable接口？<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>序列化是指把**<mark>对象的状态信息</mark>**转化为可存储或可传输的形式的过程（并不是保存类的状态，所以静态变量不会被序列化）</p><ul><li><p>如何控制某个变量不被序列化？</p><p>在变量声明前加上 <code>Transient</code> 关键字，在被反序列化后，transient变量的值设为初始值，如int型的是0</p></li><li><p>serialVersionUID有什么作用？</p><p>Java的序列化机制是通过判断类的 serialVersionUID 来验证版本一致性的。在进行反序列化时，JVM 会把传来的字节流中的 serialVersionUID与本地相应实体类的 serialVersionUID 进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即是 InvalidCastException。</p><p>如果没有为指定的 class 配置 serialVersionUID，那么 java 编译器会自动给这个 class 进行一个摘要算法，类似于指纹算法，只要这个文件有任何改动，得到的 UID 就会截然不同的，可以保证在这么多类中，这个编号是唯一的。</p><p>serialVersionUID有两种生成方式：</p><p>(1) 默认的1L,比如：private static final long serialVersionUID = 1L;</p><p>(2) 根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段</p></li><li><p>如何实现深拷贝？</p><p>在java中存在一个Cloneable接口，通过实现这个接口的类都会具备clone的能力，同时clone在内存中进行，在性能方面会比我们直接通过new生成对象要高一些，特别是一些大的对象的生成，性能提升相对比较明显。我们可以使类实现 <code>Cloneabel</code> 接口，然后重写clone方法实现深拷贝。深拷贝时只要调用该类的clone方法即可，如果类中的属性不是基础数据类型，对这个属性类也要进行同样的操作实现深拷贝。</p></li></ul><h2 id="_50-mysql-的-count-如何优化" tabindex="-1"><a class="header-anchor" href="#_50-mysql-的-count-如何优化" aria-hidden="true">#</a> 50.MySQL 的 count(*) 如何优化？</h2><p>首先要判断有没有加where条件，不加where条件的count(*)在不同的数据库引擎下有不同的实现：</p><ul><li>MyISAM引擎，会将表的总行数记录在磁盘上，因此count(*)会直接返回个数，效率较高</li><li>InnoDB引擎，则是需要一行一行的从引擎中读出来，然后累计计数。因为要支持事务并发查询，返回的行数是不确定的</li></ul><p>InnoDB是<mark>索引组织表</mark>，所有的数据都是通过B+树的方式组织起来的，<strong>主键索引的叶子节点是整行数据</strong>，<strong>普通索引(二级索引)的叶子节点是主键值</strong>，因此<strong>普通索引树的大小要比主键索引树小的多</strong>。对于count(*)，MySQL优化器会找到最小的那棵索引树然后进行遍历。</p><p>如果某张大表需要经常性的进行count(*)操作，可以考虑<strong>单独建立一张表</strong>进行保存大表的记录行数。</p><p><strong>count性能比较</strong></p><ol><li>count(primary key)：遍历整个表，把<strong>主键值拿出来，累加</strong>；</li><li>count(1)：遍历整个表，但是<strong>不取值，累加</strong>；</li><li>count(非空字段)：遍历整个表，读出这个<strong>字段，累加</strong>；</li><li>count(可以为空的字段)：遍历整个表，读出这个字段，<strong>判断不为null累加</strong>；</li><li>count(*)：遍历整个表，做了优化，<strong>不取值，累加</strong>。</li></ol><p>结论：count(字段) &lt; count(primary key) &lt; count(1) ≈ count(*)</p><p>推荐直接使用count(*）</p><p>带条件查询主要是要避免全表扫描，在查询字段上建立索引是比较好的解决办法。另外，查询条件应该尽量避免 <code>group by</code>，大规模数据分页查询limit的优化等。</p><h2 id="_51-mysql大规模数据的分页慢查询如何优化" tabindex="-1"><a class="header-anchor" href="#_51-mysql大规模数据的分页慢查询如何优化" aria-hidden="true">#</a> 51.MySQL大规模数据的分页慢查询如何优化？</h2><p>参考：<a href="https://blog.csdn.net/u013190417/article/details/126132668" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/u013190417/article/details/126132668<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>对于 <code>select * from table order by id limit offset, n</code> 这样的分页查询sql，经过实验表明随着起始位置<code>offset</code> 的增大，分页查询的效率成倍下降，当起点位置在 百万 以上的时候，对于百万级数据体量的单表，查询耗时基本上以秒为单位。而事实上，<strong>一般查询耗时超过 1 秒的 SQL 都被称为慢 SQL</strong>。</p><p>原因：MySQL在执行这样的分页查询语句时，并不是从起始位置开始查询，而是取<code>offset + N</code>行数据，最后放弃前offset条记录，只返回N行。在进行大规模数据分页查询时，如果起始位置很大，效率自然非常低下。</p><p>优化方案：</p><p>1、查询时只返回主键ID，避免<code>select *</code>，改成 <code>select id</code> （起始位置百万时，查询100条记录约500ms）</p><p>通过这种方式查询到<code>id</code>后再通过<code>id</code>查询部分数据即可：<code>select * from table where id in ()</code></p><p>2、查询时通过主键ID过滤，这个方案<strong>要求主键ID必须是数字类型</strong>，实践的思路就是取上一次查询结果的 ID 最大值，作为过滤条件，而且排序字段必须是主键 ID，不然分页排序顺序会错乱。</p><p><code>select * from table_name where id &gt; 1000000 order by id limit 100</code></p><p>3、采用ElasticSearch作为搜索引擎</p><p>当数据量越来越大的时候，尤其是出现分库分表的数据库，以上通过主键 ID 进行过滤查询，效果可能会不尽人意，例如订单数据的查询，<strong>这个时候比较好的解决办法就是将订单数据存储到 ElasticSearch 中</strong>，通过 ElasticSearch 实现快速分页和搜索，效果提升也是非常明显。</p><h2 id="_52-redis的过期删除策略和内存淘汰策略" tabindex="-1"><a class="header-anchor" href="#_52-redis的过期删除策略和内存淘汰策略" aria-hidden="true">#</a> 52.Redis的过期删除策略和内存淘汰策略</h2><p><a href="https://www.cnblogs.com/ysocean/p/12422635.html" target="_blank" rel="noopener noreferrer">Redis详解（十一）------ 过期删除策略和内存淘汰策略 - YSOcean - 博客园 (cnblogs.com)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></div><!----><footer class="page-meta"><!----><!----><!----></footer><nav class="page-nav"><!----><a href="/mynotes/codenotes/work/%E5%88%86%E5%B8%83%E5%BC%8FID.html" class="nav-link next" aria-label="分布式ID"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">分布式ID<span class="icon iconfont icon-storage"></span></div></a></nav><!----><!----><!--]--></main><!--]--><!----><!--]--></div><!--]--><!----><!--]--></div>
    <script type="module" src="/mynotes/assets/app.fea2bdf4.js" defer></script>
  </body>
</html>
