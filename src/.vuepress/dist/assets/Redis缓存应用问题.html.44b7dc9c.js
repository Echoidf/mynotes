import{_ as r}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as t,c as s,e}from"./app.fea2bdf4.js";const n={},o=e('<h2 id="一、缓存穿透" tabindex="-1"><a class="header-anchor" href="#一、缓存穿透" aria-hidden="true">#</a> 一、缓存穿透</h2><p>当用户访问的数据，<strong>既不在缓存中，也不在数据库中</strong>，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是<strong>缓存穿透</strong>的问题。若黑客利用此漏洞进行攻击可能压垮数据库。</p><p>解决方案：</p><ul><li><p><strong>对空值缓存</strong></p><p>如果一个查询返回的数据为空，我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间应该短些，最长不超过五分钟</p></li><li><p><strong>设置可访问的白名单</strong></p><p>定义一个可以访问的名单，每次访问和白名单的 id 进行比较，如果访问 id 不在白名单里面，进行拦截，不允许访问, 比如使用 <strong>bitmaps</strong> 实现</p></li><li><p><strong>采用布隆过滤器</strong></p><p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难</p></li><li><p><strong>进行实时监控</strong></p><p>当发现 <strong>Redis 的命中率</strong>开始急速降低, 需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务</p></li></ul><h2 id="二、缓存击穿" tabindex="-1"><a class="header-anchor" href="#二、缓存击穿" aria-hidden="true">#</a> 二、缓存击穿</h2><p>key 对应的数据存在，但在 redis 中过期，此时若有大量并发请求过来，这些请求发现缓存过期, 会从后端 DB 加载数据并回设到缓存，这时大并发的请求可能会瞬间把后端 DB 压垮</p><p>比如某个热点数据, 可能会在某些时间点, 被超高并发地访问, 容易出现缓存击穿</p><p>解决方案：</p><ul><li><strong>预先设置热门数据</strong>：在 redis 高峰访问之前，把一些热门数据提前存入到 redis 里面，加大这些热门数据 key 的时长</li><li><strong>实时调整</strong>： 现场监控哪些数据热门，实时调整 key 的过期时长</li><li><strong>使用排他锁</strong>：</li></ul>',9),i=[o];function p(l,a){return t(),s("div",null,i)}const _=r(n,[["render",p],["__file","Redis缓存应用问题.html.vue"]]);export{_ as default};
