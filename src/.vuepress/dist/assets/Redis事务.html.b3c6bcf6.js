import{_ as e}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as a,c as d,e as c}from"./app.fea2bdf4.js";const i={},h=c('<h2 id="一、概念" tabindex="-1"><a class="header-anchor" href="#一、概念" aria-hidden="true">#</a> 一、概念</h2><p>1、Redis 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行 2、事务在执行的过程中，不会被其他客户端发送来的命令请求所打断 3、Redis 事务的主要作用就是串联多个命令防止别的命令插队</p><h2 id="二、redis事务三特性" tabindex="-1"><a class="header-anchor" href="#二、redis事务三特性" aria-hidden="true">#</a> 二、Redis事务三特性</h2><h3 id="_1-单独的隔离操作" tabindex="-1"><a class="header-anchor" href="#_1-单独的隔离操作" aria-hidden="true">#</a> 1.单独的隔离操作</h3><ul><li>事务中的所有命令都会序列化、按顺序地执行</li><li>事务在执行的过程中，不会被其他客户端发送来的命令请求所打断</li></ul><h3 id="_2-没有隔离级别的概念" tabindex="-1"><a class="header-anchor" href="#_2-没有隔离级别的概念" aria-hidden="true">#</a> 2.没有隔离级别的概念</h3><p>队列中的命令(指令), 在没有提交前都不会实际被执行</p><h3 id="_3-不保证原子性" tabindex="-1"><a class="header-anchor" href="#_3-不保证原子性" aria-hidden="true">#</a> 3.不保证原子性</h3><p>事务执行过程中, 如果有指令执行失败，其它的指令仍然会被执行, 没有回滚</p><h2 id="三、相关指令" tabindex="-1"><a class="header-anchor" href="#三、相关指令" aria-hidden="true">#</a> 三、相关指令</h2><p><img src="https://s2.loli.net/2023/02/03/NxjCuZqL3XV6BiP.png" alt="20230203145557"></p><ol><li>从输入 Multi 命令开始，输入的命令都会依次进入命令队列(<code>QUEUED</code>)中，但<strong>不会执行</strong>(类似 Mysql 的 <code>start transaction</code> 开启事务)</li><li>输入 Exec 后，Redis 会将之前的命令队列中的命令依次执行(类似 Mysql 的 <code>commit</code> 提交事务)</li><li>组队 <code>Multi</code> 的过程中可以通过 <code>discard</code> 来放弃组队(类似 Mysql 的 <code>rollback</code> 回顾事务)</li><li>如果在组队阶段报错, 会导致 exec 失败, 那么事务的所有指令都不会被执行，这个情况是具有原子性的</li></ol><h2 id="四、事务冲突及解决方案" tabindex="-1"><a class="header-anchor" href="#四、事务冲突及解决方案" aria-hidden="true">#</a> 四、事务冲突及解决方案</h2><p>例如：在购票时，如果只有10张票，当同时有三个请求购票，第一个请求购票6张，第二个请求购票5张，第三个请求购票1张，如果没有事务控制就会出现超卖现象。</p><h3 id="_1-悲观锁" tabindex="-1"><a class="header-anchor" href="#_1-悲观锁" aria-hidden="true">#</a> 1.悲观锁</h3><p>Pessimistic Lock--总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。</p><blockquote><p>Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。传统的关系型数据库里边也用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p></blockquote><p>缺点：性能较低</p><h3 id="_2-乐观锁" tabindex="-1"><a class="header-anchor" href="#_2-乐观锁" aria-hidden="true">#</a> 2.乐观锁</h3><p>Optimistic Lock--总是乐观地假设最好的情况，每次去拿数据的时候都认为别人不会修改这个数据，所以不会上锁，只会要对数据进行更新时判断一下在此期间(拿到数据到更新的期间)别人有没有去更改这个数据，可以使用<a href="">版本号机制和CAS算法</a>实现。</p><blockquote><p>乐观锁适用于多读的应用类型，这样可以提高吞吐量。Redis 就是利用这种 <code>check-and-set</code> 机制实现事务的</p></blockquote><h3 id="_3-watch-unwatch" tabindex="-1"><a class="header-anchor" href="#_3-watch-unwatch" aria-hidden="true">#</a> 3.watch &amp; unwatch</h3><p><img src="https://s2.loli.net/2023/02/04/nv9gBKu6QOXYUrP.png" alt="20230204143030"></p><p>如上图所示，初始值 k1=110 k2=30</p><p>在开启事务之前两个Redis连接都执行了 <code>watch k1</code>指令，相当于对k1的版本号进行了一个监控</p><p>第一个连接先执行事务 <code>exec</code>,执行成功</p><p>第二个连接由于k1的值已被改变，事务终止，就返回了nil,队列中的k1和k2都没有改变</p><p><code>unwatch</code> :取消 watch 命令对所有 key 的监视</p><p>如果在执行 <code>watch</code> 命令后，exec 命令或 discard 命令先被执行了的话，那么就不需要再执行 <code>unwatch</code> 了</p>',29),r=[h];function t(o,s){return a(),d("div",null,r)}const p=e(i,[["render",t],["__file","Redis事务.html.vue"]]);export{p as default};
