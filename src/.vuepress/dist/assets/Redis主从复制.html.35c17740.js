import{_ as l}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as p,c,a as s,b as n,d as e,w as t,e as i,r as d}from"./app.47a8cb65.js";const o={},r=i(`<h2 id="一、简介" tabindex="-1"><a class="header-anchor" href="#一、简介" aria-hidden="true">#</a> 一、简介</h2><p><img src="https://s2.loli.net/2023/02/14/iB2rlPg7XjmNIC3.png" alt="20230214192640.png"></p><p>Master【主】：以写为主</p><p>Slaver【从】：以读为主</p><p>主机数据更新后会自动同步到从机，好处：</p><ul><li>读写分离, 提升效率</li><li>负载均衡</li><li>容灾快速恢复，如果某个 slaver , 不能正常工作, 可以切换到另一个 slaver</li><li>高可用（集群）基石︰除了上述作用以外，主从复制还是哨兵和集群能够实施的基础</li></ul><p>要求：一 主多从, 不能有多个 Master( 如果有多个主服务器 Master, 那么 slaver 不能确定和哪个 Master 进行同步, 出现数据紊乱）</p><h2 id="二、主从搭建" tabindex="-1"><a class="header-anchor" href="#二、主从搭建" aria-hidden="true">#</a> 二、主从搭建</h2><p>本文在一台Linux服务器上通过三个不同的端口来模拟三个Redis服务的一主二从结构</p><h3 id="_1、创建三个配置文件" tabindex="-1"><a class="header-anchor" href="#_1、创建三个配置文件" aria-hidden="true">#</a> 1、创建三个配置文件</h3><p><code>公用配置文件/zqlredis/redis.conf</code></p><div class="language-she line-numbers-mode" data-ext="she"><pre class="language-she"><code>#修改下面两个选项
daemonize yes
#只使用rdb备份
appendonly no 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>三个配置文件 <code>redis6379.conf </code>，<code>redis6380.conf</code>， <code>redis6381.conf</code></p><div class="language-she line-numbers-mode" data-ext="she"><pre class="language-she"><code>include /zqlredis/redis.conf
pidfile /var/run/redis_6379.pid
port 6379
dbfilename dump6379.rdb
#其他两个文件依此修改
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2、启动三个redis服务" tabindex="-1"><a class="header-anchor" href="#_2、启动三个redis服务" aria-hidden="true">#</a> 2、启动三个Redis服务</h3><p><img src="https://s2.loli.net/2023/02/15/VWaExKfdn9Q26Aw.png" alt="image.png"></p><h3 id="_3、配置主从" tabindex="-1"><a class="header-anchor" href="#_3、配置主从" aria-hidden="true">#</a> 3、配置主从</h3><p>将 6380 和 6381 配置成 slaver, 6379 作为主机Master</p><p>在Slave的Redis客户端执行以下命令</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>slaveof <span class="token number">127.0</span>.0.1 <span class="token number">6379</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="https://s2.loli.net/2023/02/15/hEpgGwWRzoDCYQI.png" alt="image.png"></p><p>现在6380，6381端口的角色已经变成了slave，master_port为6379</p><h2 id="三、主从复制原理" tabindex="-1"><a class="header-anchor" href="#三、主从复制原理" aria-hidden="true">#</a> 三、主从复制原理</h2>`,23),u=s("li",null,[s("p",null,"Slave 启动成功连接到 master 后会发送一个 sync 命令")],-1),m=s("li",null,[s("p",null,"只要是重新连接 master,一次完全同步（全量复制)将被自动执行")],-1),h=i(`<h2 id="四、多种模式" tabindex="-1"><a class="header-anchor" href="#四、多种模式" aria-hidden="true">#</a> 四、多种模式</h2><h3 id="_1、一主二仆" tabindex="-1"><a class="header-anchor" href="#_1、一主二仆" aria-hidden="true">#</a> 1、一主二仆</h3><ul><li>如果从服务器 down 了, 重新启动, 仍然可以获取 Master 的最新数据</li><li>如果主服务器 down 了, 从服务器并不会抢占为主服务器, 当主服务器恢复后,从服务器仍然指向原来的服务器</li></ul><h3 id="_2、薪火相传" tabindex="-1"><a class="header-anchor" href="#_2、薪火相传" aria-hidden="true">#</a> 2、薪火相传</h3><ul><li>上一个 Slave 可以是下一个 Slave 的 Master，Slave 同样可以接收其他 Slaves 的连接和同步请求，那么该 Slave 作为了链条中下一个的 Master, 可以有效减轻 Master 的写压力,去中心化降低风险</li><li>风险：一旦某个 slave 宕机，后面的 slave 都没法同步</li><li>主机宕机之后，从机还是从机，无法写数据了</li></ul><h3 id="_3、反客为主" tabindex="-1"><a class="header-anchor" href="#_3、反客为主" aria-hidden="true">#</a> 3、反客为主</h3><p>当一个 master 宕机后, 指向 Master 的 slave 可以升为 master, 其 后面的 slave 不用做任何修改</p><p>升级Master方法：在选定的从服务器上执行下列指令</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>slaveof no one
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_4、哨兵模式-sentinel" tabindex="-1"><a class="header-anchor" href="#_4、哨兵模式-sentinel" aria-hidden="true">#</a> 4、哨兵模式（sentinel）</h3><p>反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</p><p>在一主二仆模式下，创建<code>/zqlredis/sentinel.conf</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>sentinel monitor redis_master <span class="token number">127.0</span>.0.1 <span class="token number">6379</span> <span class="token number">1</span>
<span class="token comment">#redis_master 为监控对象起的服务器名称</span>
<span class="token comment">#末尾的1表示只要有1个哨兵同意迁移就可以切换</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动哨兵：<code>redis-sentinel sentinel.conf</code></p><p><img src="https://s2.loli.net/2023/02/15/ckTtOPS3NzqaCxX.png" alt="image.png"></p><p>哨兵如何在从机中, 推选新的 Master 主机, 选择的条件依次为：</p><ol><li>优先级在 redis.conf 中默认：replica-priority 100，值越小优先级越高</li><li>偏移量是指获得原主机数据的量, 数据量最全的优先级高</li><li>每个 redis 实例启动后都会随机生成一个 40 位的 runid, 值越小优先级越高</li></ol><h2 id="五、集群" tabindex="-1"><a class="header-anchor" href="#五、集群" aria-hidden="true">#</a> 五、集群</h2><h3 id="_1、去中心化集群" tabindex="-1"><a class="header-anchor" href="#_1、去中心化集群" aria-hidden="true">#</a> 1、去中心化集群</h3><p><strong>redis3.0 提供解决方案-无中心化集群配置</strong></p><p><img src="https://s2.loli.net/2023/02/15/i6TGjRhCtO3DU5r.png" alt="image.png"></p><ol><li><p>各个 Redis 服务仍然采用主从结构</p></li><li><p>各个 Redis 服务是连通的, 任何一台服务器, 都可以作为请求入口</p></li><li><p>各个 Redis 服务器因为是连通的, 可以进行请求转发</p></li><li><p>这种方式, 就是无中心化集群配置, 可以看到，只需要 6 台服务器即可搞定</p></li><li><p><strong>Redis哈希槽：</strong></p><p><strong>一个 redis 集群包含 16384 个哈希槽（hash slot）</strong>，数据库中的每个数据都属于这16384个哈希槽中的一个。集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽。集群中的每一个节点负责处理一部分哈希槽。</p></li></ol><h3 id="_2、创建集群" tabindex="-1"><a class="header-anchor" href="#_2、创建集群" aria-hidden="true">#</a> 2、创建集群</h3><ol><li><strong>通过端口模拟6个Redis服务器搭建集群</strong></li></ol><p>配置文件目录如下：</p><p><img src="https://s2.loli.net/2023/02/15/qL5K6rVNkcEiMOb.png" alt="image.png"></p><p>其中 <code>redis6379.conf </code>内容如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>include /zqlredis/redis.conf
pidfile /var/run/redis_6379.pid
port <span class="token number">6379</span>
<span class="token comment">#rdb文件不能指定路径</span>
dbfilename dump6379.rdb
<span class="token comment">#打开集群模式</span>
cluster-enabled <span class="token function">yes</span>  
<span class="token comment">#设置结点配置文件名</span>
cluster-config-file /zqlredis/nodes-6379.conf
<span class="token comment">#设置结点失联时间（毫秒），失联超时后将自动进行主从切换</span>
cluster-node-timeout <span class="token number">15000</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其他配置文件依此类推</p><ol start="2"><li><strong>启动6个Redis服务</strong></li></ol><p><img src="https://s2.loli.net/2023/02/15/ZlcdMCgiPVDuB61.png" alt="image.png"></p><p>​ 发现结点配置文件也成功生成了：</p><p><img src="https://s2.loli.net/2023/02/15/odgTv4JiP7Emye2.png" alt="image.png"></p><ol start="3"><li><strong>将6个结点合成一个集群</strong></li></ol><p>​ 【合成集群的命令需要Ruby的环境，Redis6版本以上已经安装了】</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>redis-cli <span class="token parameter variable">--cluster</span> create --cluster-replicas <span class="token number">1</span> <span class="token number">192.168</span>.50.132:6379 <span class="token number">192.168</span>.50.132:6380 <span class="token number">192.168</span>.50.132:6381 <span class="token number">192.168</span>.50.132:6389 <span class="token number">192.168</span>.50.132:6390 <span class="token number">192.168</span>.50.132:6391 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>注意事项：</p><ul><li>此处不要用 127.0.0.1, 要用真实 IP 地址</li><li>replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组</li><li>搭建集群如果没有成功, 把 sentinel 进程 kill 掉重新试一下</li></ul><p><img src="https://s2.loli.net/2023/02/15/LVgkrucY168IUEf.png" alt="image.png"></p><p>M代表主机，S代表从机，S后面的序列号可以判断出其从属关系：</p><table><thead><tr><th>主</th><th>从</th></tr></thead><tbody><tr><td>6379</td><td>6390</td></tr><tr><td>6380</td><td>6391</td></tr><tr><td>6381</td><td>6389</td></tr></tbody></table><h3 id="_3、集群使用" tabindex="-1"><a class="header-anchor" href="#_3、集群使用" aria-hidden="true">#</a> 3、集群使用</h3><p>注意：一个集群至少要有三个主节点</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#集群方式登录</span>
redis-cli <span class="token parameter variable">-c</span> <span class="token parameter variable">-p</span> <span class="token number">6379</span>
<span class="token comment">#查看集群信息，主从对应关系</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> cluster nodes
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://s2.loli.net/2023/02/15/v82kF1CPLRpOwiU.png" alt="image.png"></p><p><strong>哈希槽solts</strong></p><p>一个 Redis 集群包含 16384 个插槽（hash slot），编号从 0-16383, Reids 中的每个键都属于这 16384 个插槽的其中一个</p><p><strong>如何在集群中录入值？</strong></p><p>通过redis-cli -c -p 6379登录后，可以实现自动重定向</p><p><img src="https://s2.loli.net/2023/02/15/qV7sxKLkaQjRNBF.png" alt="image.png"></p><p>不在一个 slot 下的键值，是不能使用 mget，mset 等多键操作</p><p><img src="https://s2.loli.net/2023/02/15/JFu2wtSfWi9pCLo.png" alt="image.png"></p><p>可以通过{}来定义组的概念，从而使 key 中{}内相同内容的键值对放到一个 slot</p><p><img src="https://s2.loli.net/2023/02/15/uOVvXhmfcjlP178.png" alt="image.png"></p><p><strong>查询集群中的值</strong></p><ul><li>指令: CLUSTER KEYSLOT [key] 返回 key 对应的 slot 值</li><li>指令: CLUSTER COUNTKEYSINSLOT [slot] 返回 slot 有多少个 key</li><li>指令: CLUSTER GETKEYSINSLOT [slot] [count] 返回 count 个 slot 槽中的键</li></ul><h3 id="_4、集群故障恢复" tabindex="-1"><a class="header-anchor" href="#_4、集群故障恢复" aria-hidden="true">#</a> 4、集群故障恢复</h3><ul><li><p>如果主节点下线, 从节点会自动升为主节点</p></li><li><p>主节点恢复后，主节点回来变成从机</p></li><li><p>如果所有某一段插槽的主从节点都宕掉，Redis 服务是否还能继续, 要根据不同的配置而言</p><p>redis.conf中配置项：<code>cluster-require-full-coverage</code></p><p>该选项为yes代表整个集群都会挂掉</p><p>该选项为no代表只是该插槽数据不能使用也不能存储</p></li></ul><h3 id="_5、jedis开发" tabindex="-1"><a class="header-anchor" href="#_5、jedis开发" aria-hidden="true">#</a> 5、Jedis开发</h3><p><code>pom.xml</code></p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>redis.clients<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jedis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.2.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JedisClusterUse</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HostAndPort</span><span class="token punctuation">&gt;</span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/*
         * set集合可以加入多个地址
         * 如果使用集群需要的打开相关的端口防火墙
         */</span>
        set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HostAndPort</span><span class="token punctuation">(</span><span class="token string">&quot;192.168.50.132&quot;</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 可以传入set集合，也可单独传入一个地址HostAndPort</span>
        <span class="token class-name">JedisCluster</span> jedisCluster <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisCluster</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>
        jedisCluster<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;address&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;beijing&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> address <span class="token operator">=</span> jedisCluster<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;address&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;address=&quot;</span> <span class="token operator">+</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="六、集群优缺点" tabindex="-1"><a class="header-anchor" href="#六、集群优缺点" aria-hidden="true">#</a> 六、集群优缺点</h2><h3 id="_1、优点" tabindex="-1"><a class="header-anchor" href="#_1、优点" aria-hidden="true">#</a> 1、优点</h3><ul><li>实现扩容</li><li>分摊压力</li><li>无中心配置相对简单</li></ul><h3 id="_2、缺点" tabindex="-1"><a class="header-anchor" href="#_2、缺点" aria-hidden="true">#</a> 2、缺点</h3><ul><li>多键操作是不被支持的</li><li>多键的 Redis 事务是不被支持的。lua 脚本不被支持</li><li>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而其它方案想要迁移 至 redis cluster，需要整体迁移而不是逐步过渡，复杂度较大</li></ul>`,67);function v(k,g){const a=d("font");return p(),c("div",null,[r,s("ul",null,[u,s("li",null,[s("p",null,[n("Master 接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后, master 将传送整个数据文件到 slave,以完成一次完全同步，slave 服务在接收到数据库文件数据后，将其存盘并加载到内存中, 即 "),e(a,{color:"red"},{default:t(()=>[n("全量复制")]),_:1})])]),s("li",null,[s("p",null,[n("Master 数据变化了, 会将新的收集到的修改命令依次传给 slave, 完成同步, 即 "),e(a,{color:"red"},{default:t(()=>[n("增量复制 ")]),_:1})])]),m]),h])}const _=l(o,[["render",v],["__file","Redis主从复制.html.vue"]]);export{_ as default};
