---
title: 协程顺序打印和交替打印  
icon: edit
# 分类  
category:
- Golang
# 标签
tag:
- 协程
sticky: false
# 排序越大越靠前
star: 40  
# 添加到文章列表
article: true
# 添加到时间线 
timeline: true
---

本文展示一下如何控制Golang的协程进行顺序执行或者交替执行

## 1.顺序执行

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	fmt.Println("=====通过 channel 顺序打印=====")
	printOrderlyByChannel()
	fmt.Println("=====通过 WaitGroup 顺序打印=====")
	printOrderlyByWaitGroup()
}

// 协程顺序打印 A B C
func printOrderlyByChannel() {
	wg := &sync.WaitGroup{}
	wg.Add(3)
	ch := make(chan string)
	ch2 := make(chan string)
	go func ()  {
		defer wg.Done()
		fmt.Println("A")
		ch <- "B"
	}()

	go func ()  {
		defer wg.Done()
		fmt.Println(<- ch)
		ch2 <- "C"
	}()

	go func ()  {
		defer wg.Done()
		fmt.Println(<- ch2)
	}()

	wg.Wait()
}

func printOrderlyByWaitGroup() {
	wg := &sync.WaitGroup{}
	
	wg.Add(1)
	go func ()  {
		fmt.Println("A")
		wg.Done()
	}()

	wg.Wait()
	wg.Add(1)
	go func ()  {
		fmt.Println("B")
		wg.Done()
	}()

	wg.Wait()
	wg.Add(1)
	go func ()  {
		fmt.Println("C")
		wg.Done()
	}()

	wg.Wait()
}
```



## 2.交替执行

使用两个channel

```go
func main() {
	wg := &sync.WaitGroup{}
	wg.Add(2)
	chA := make(chan int, 1)
	chB := make(chan int)

	chA <- 1

	go func() {
		defer wg.Done()
		for i := 0; i < 3; i++ {
			<-chA
			fmt.Println(string(rune('a' + i)))
			chB <- 1
		}
	}()

	go func() {
		defer wg.Done()
		for i := 0; i < 3; i++ {
			<-chB
			fmt.Println(i + 1)
			if i == 2 {
				break
			}
			chA <- 1
		}
	}()

	wg.Wait()
}
```

