---
title: 面试题记录
icon: storage
# 分类
category:
  - 面试
# 标签
tag:
  - 面试题
  - java
  - 后端
sticky: false
# 是否收藏在博客主题的文章列表中，当填入数字时，数字越大，排名越靠前。
star: 20
# 是否将该文章添加至文章列表中
article: true
timeline: true
---
## 1.电商钱包

业务背景：电商业务中，需要给电商app设计一个用户钱包，用户可以往钱包中充值，购买商品时用户可以使用钱包中的钱消费，商品申请退款成功后钱会退回钱包中，用户也可以申请提现把钱提到银行卡中

用程序实现如下api接口

1. 查询用户钱包余额
2. 用户消费100元的接口
3. 用户退款20元接口

4查询用户钱包金额变动明细的接口

请给出建表语句和对应的代码（只要能实现上面api接口要求即可，不相关的表和代码不用写）

```sql
drop table if exists `user_wallet`;
create table `user_wallet` (
    `id` BIGINT(20) primary key auto_increment,
	`name` varchar(32) not null default '',
    `amount` decimal(7,2) not null COMMENT '账户余额',
    `pay_pwd` varchar(255) not null CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci,
    `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  	`update_time` datetime DEFAULT NULL COMMENT '更新时间',
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

DROP TABLE IF EXISTS `user_wallet_record`;
CREATE TABLE `user_wallet_record` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT,
  `user_id` bigint DEFAULT NULL COMMENT '钱包id',
  `order_id` bigint DEFAULT NULL COMMENT '订单id',
  `amount` decimal(7,2) DEFAULT NULL COMMENT '金额',
  `type` int DEFAULT NULL COMMENT '0-支出 1-退款 2-提现',
  `bank_serial_number` int DEFAULT NULL COMMENT '银行流水号',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
```

对应的sql查询代码：

```sql
-- 查询用户钱包余额
select `amount` from `user_wallet` where id = #{id};

-- 用户消费100元的接口
-- 1.生成订单
insert into `user_wallet_record` values(
	#{user_id}, #{order_id}, 100, 0, #{bank_serial_number}, #{update_time}
);
-- 2.减少账户余额
update `user_wallet` set `amount` = `amount` - 100 where id = #{id};

-- 用户退款20元接口
-- 1.生成订单
insert into `user_wallet_record` values(
	#{user_id}, #{order_id}, 20, 1, #{bank_serial_number}, #{update_time}
);
-- 2.增加
update `user_wallet` set `amount` = `amount` + 20 where id = #{id};
```

## 2.RPC协议

RPC (Remote Procedure Call)即**远程过程调用**，是分布式系统常见的一种通信方法。

RPC需要解决的三个问题：

- Call ID映射——在RPC中，**所有的函数都必须有自己的一个ID**。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。
- 序列化和反序列化——需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。
- 网络传输——网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。

主流的RPC框架：

- Thrift
- Dubbo
- SpringCloud

RPC协议和HTTP协议区别：

RPC，可以基于TCP协议，也可以基于HTTP协议

RPC主要⽤于公司内部的服务调⽤，性能消耗低，传输效率⾼，服务治理⽅便。HTTP主要⽤于对外的异构环境，浏览器接⼝调⽤，APP接⼝调⽤，第三⽅接⼝调⽤等。

## 3.TCP三次握手四次挥手

TCP 在传输之前会进行三次沟通，一般称为“三次握手”，传完数据断开的时候要进行四次沟通，一般称为“四次挥手”

- 第一次握手：主机 A 发送数据包到主机 B，要求建立连接
- 第二次握手：主机 B 收到请求后要确认联机信息，向 A 发送数据包，表示让客户端确认是否能收到
- 第三次握手：主机 A 再次发送确认包(ACK)，表示确认收到服务器的包

四次挥手：

- 第一次挥手：客户端发送包，告诉服务器需要关闭连接，表示自己不用发送数据了，但是还可以接收数据
- 第二次挥手：服务端发送一个ACK的确认包，告诉客户端接收到关闭的请求，但是还没有准备好
- 第三次挥手：服务端准备好关闭连接时，发送FIN标记的包，告诉客户端准备关闭了
- 第四次挥手：客户端接收到服务端的关闭请求，再发送ACK标记的确认包，等待服务端可能请求重传的ACK包

## 4.AutoWired和Resource注解的区别

AutoWired注解是Spring的注解，只根据type注入bean，不会按照name匹配，如果有多个实现类，需要依赖@Qualifier或@Primary注解一起来修饰

Resource是Java的原生注解，支持按照name和type进行注入，默认按照name

## 5.TCP和UDP区别

TCP/IP协议集包括应用层，传输层，网络层，网络访问层。

HTTP协议在应用层，IP协议属于网络层。

TCP（Transmission Control Protocol，传输控制协议）是**面向连接**的协议，也就是说，在收发数据前，必须和对方建立**可靠**的连接，面向字节流。（三次握手四次挥手）

UDP  (User Data Protocol，用户数据报协议)  是一个**非连接的协议**，传输数据之前源端和终端**不建立连接**， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。UDP是不可靠的。面向数据报文。

## 6.MySQL的索引

- **优缺点**

  > 能大大加快数据检索速度，但是需要占用一定的物理空间，而且创建和维护索引都需要花费时间
  >
- **数据结构**

  1. B+树索引

     > 具有有序性，并且所有的数据都存放在叶子节点，所以查找的效率非常高，并且支持排序和范围查找。
     >
  2. 哈希索引

     > 基于哈希表实现，对于每一行数据，存储引擎会对索引列通过哈希算法进行哈希计算得到哈希码，查找一个数据的时间复杂度就是O(1)，一般多用于精确查找，不支持范围查找、模糊查询，可能有哈希冲突
     >
- **MySQL索引种类**

  - 主键索引【PRIMARY KEY】：数据列不允许重复，不能为NULL，一个表只能有一个主键索引
  - 组合索引：由多个列值组成的索引
  - 唯一索引【UNIQUE】：数据列不允许重复，可以为NULL,索引列的值必须唯一的，如果是组合索引，列值的组合必须唯一
  - 全文索引【FULLTEXT KEY】：对文本的内容进行搜索
  - 普通索引【INDEX】：基本的索引类型，可以为NULL
- ### 聚簇索引和非聚簇索引

  最主要的区别是**数据和索引是否分开存储**


  - 聚簇索引：将数据和索引放到一起存储，索引结构的叶子节点保留了数据行。
  - 非聚簇索引：将数据进和索引分开存储，索引叶子节点存储的是指向数据行的地址。
- **如何创建索引**

  1、`CREATE INDEX index_name ON table_name (column_list);`

  2、创建表时创建索引：

  ```sql
  create table user(
  	id INT PRIMARY KEY,
      information text,
      FULLTEXT KEY(infomation)
  );
  ```

  3、`ALTER TABLE table_name ADD INDEX index_name (column_list);`

  4、删除索引：`ALTER table table_name drop key index_name;`

  5、创建前缀索引：`ALTER TABLE table_name ADD key(column_name(prefix_length));`

## 7.单例模式

它出现目的是为了保证一个类在系统中只有一个实例，并提供一个访问它的全局访问点。

应用场景：

1、有频繁实例化然后销毁的情况，也就是频繁的 new 对象，可以考虑单例模式；

2、创建对象时耗时过多或者耗资源过多，但又经常用到的对象；

3、频繁访问 IO 资源的对象，例如数据库连接池或访问本地文件。

例如网站在线人数计数器、配置文件的访问类、数据库连接池等。

**如何实现单例模式？**

- 饿汉式（静态常量）

  ```java
  public class Singleton {
      private final static Singleton INSTANCE = new Singleton();

      private Singleton() {}

      public static Singleton getInstance() {
          return INSTANCE;
      }
  }
  ```
- 饿汉式（将类的实例化放在静态代码块）
- 枚举——可以避免多线程同步问题，还可以防止通过反射和反序列化来重新创建的对象

  ```java
  public enum Singleton {
      INSTANCE;
      public void whateverMethod() {

      }
  }
  ```

  将已有的类改造为单例类

  ```java
  public class Singleton {
      private Singleton(){
      }   
      public static enum SingletonEnum {
          SINGLETON;
          private Singleton instance = null;
          private SingletonEnum(){
              instance = new Singleton();
          }
          public Singleton getInstance(){
              return instance;
          }
      }
  }
  ```
- 双重检查

下面是一个Jedis连接池工具类案例：

```java
import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisPool;
import redis.clients.jedis.JedisPoolConfig;

/**
 * @author 左齐亮
 * @version 1.0
 * 使用连接池方式获取Redis连接
 */
public class JedisPoolUtil {
    // volatile作用：
    // 1.线程可见性：当一个线程去修改一个共享变量时，其他线程立即得知改变
    // 2.顺序的一致性；禁止指令重排
    private static volatile JedisPool jedisPool = null;

    //保证每次调用返回的是jedisPool是单例
    public static JedisPool getJedisPoolInstance() {
        if(null == jedisPool) {
            synchronized (JedisPoolUtil.class) {
                if(null == jedisPool){   //单例的双重校验
                    JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
                    jedisPoolConfig.setMaxTotal(200);
                    jedisPoolConfig.setMaxIdle(32);
                    jedisPoolConfig.setMaxWaitMillis(60 * 1000);
                    jedisPoolConfig.setBlockWhenExhausted(true);
                    jedisPoolConfig.setTestOnBorrow(true);
                    jedisPool = new JedisPool(jedisPoolConfig, "192.168.50.132", 6379, 60000);
                }
            }
        }
        return jedisPool;
    }

    //释放连接资源
    public static void release(Jedis jedis) {
        if(null != jedis) jedis.close();
    }
}
```

## 8.JVM有哪些区域

JVM内存区域主要分为线程私有区域、线程共享区域、直接内存

- 线程私有区域：程序计数器、虚拟机栈、本地方法区，生命周期与线程相同
- 线程共享区：随虚拟机的启动/关闭而创建/销毁

  分为**方法区**（**永久代**）和**类实例区**（java堆）

  Java堆从GC的角度又分为**新生代**（eden、from survivor、to survivor）、**老年代**

  在Java8中，`永久代已经被移除，`被一个称为**“元数据区”**（元空间）的区域所取代，元空间与永久代最大的区别就是不在虚拟机中，而是使用**本地内存**。
- 直接内存：存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用

## 9.sleep和wait的区别

- sleep() 方法属于**Thread**类，而 wait() 方法属于**Object**类
- sleep() 方法必须要传递一个超时时间的参数，参数时间内让出cpu给其他线程，但是**不会释放对象锁**，当指定的时间到了又会自动恢复运行状态，线程**自动唤醒**
- 当调用wait() 方法的时候，线程会**放弃对象锁**，进入等待此对象的等待锁定池，只有针对此对象调用 **notify()** 方法或者 **notifyAll()** 后休眠的线程才能被唤醒
- sleep可以在任何地方使用，而wait只能在同步方法或者同步块中使用，调用它的前提是当前线程占有锁，即**必须配合 synchronized 一起使用**
- 它们都可以被 **interrupted** 方法中断

## 10.JUC类知道哪些？

- volatile

  > volatile是Java提供的一种轻量级的同步机制
  >
  > 保证可见性
  >
  > 不保证原子性
  >
  > 禁止指令重排
  >

  要保证原子性可以使用juc包下的 AutomicInteger、AutomicLong等
- locks包

  该包下有两个重要的接口Lock和ReadWriteLock(读写锁)，还有两个实现类ReentantLock、ReentrantReadWriteLock
- 一些线程安全的类

  比如ArrayBlockingQueue、ConcurrentHashMap、DelayQueue、FutureTask、Semaphore、ThreadPoolExecutor

## 11.SpringBoot如何实现自动装配？

**SpringBoot启动流程：**

- 首先从main找到run()方法，在执行run()方法之前new一个SpringApplication对象
- 进入run()方法，创建应用监听器SpringApplicationRunListeners开始监听
- 然后加载SpringBoot配置环境(ConfigurableEnvironment)，然后把配置环境(Environment)加入监听对象中
- 然后加载应用上下文(ConfigurableApplicationContext)，当做run方法的返回对象
- 最后创建Spring容器，refreshContext(context)，实现starter自动化配置和bean的实例化等工作。

**SpringBoot自动装配：**

- @SpringBootApplication是复合注解，包含@EnableAutoConfiguration和@Configuration
- @Configuration：被标注的类等于在Spring的XML配置文件中（applicationContext.xml)，装配所有bean事务，提供了一个Spring的上下文环境
- @EnableAutoConfiguration会导入AutoConfigurationImportSelector这个类，这个类会利用SpringFactoriesLoader组件加载jar包里面**META-INF/spring.factories**配置文件里面填写的配置类，将这些配置类过滤一波后加载到Spring容器中

## 12.Bean的生命周期

## 13.Redis有哪些数据类型？

- **string**

  一个 Redis 中字符串 value 最多可以是 512M，**特点：二进制安全，可以包含任何数据，包括图片或者序列化对象**
- **hash**

  一个键值对集合，hash 适合用于存储对象， 类似 Java 里面的Map<String,Object>
- **list**

  保存多个数据，底层使用双向链表存储结构。应用场景如：系统通知，按照时间顺序展示，将最近的通知列在前面
- **set**

  set 是可以自动排重的, 即值是**不允许重复**的
- **zset(sorted_set)**

  与 set 非常相似，是一个没有重复元素的字符串集合

  不同之处是有序集合的每个成员都关联了一个评分(score),这个评分(score)被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以重复

## 14.Redis如何实现分布式锁？

```shell
#setnx指令只能对不存在的键进行设置，可以用来设置锁
#setnx lock value
#一般同时设置锁的过期时间，防止死锁的同时保证两个操作的原子性
set lock val nx ex seconds
#删除锁
del lock
```

在使用RedisTemplate操作Redis时，删除锁的操作缺乏原子性，可以**使用UUID作为锁的值**，在释放锁时判断释放的锁是不是同一把锁，防止误删锁，进一步优化可以使用**LUA脚本保证删除的原子性**

## 15.HashMap底层原理

- HashMap底层使用数组+链表+红黑树
- HashMap具有很快的访问速度，但是不能保证遍历顺序（LinkedHashMap增加了双向链表，可以保证遍历顺序）
- HashMap 最多只允许一条记录的键为 null，允许多条记录的值为 null
- HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能导致数据不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap
- HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。每个结点 Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。

  capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。

  loadFactor：负载因子，默认为 0.75。（这是时间和空间成本的折中）

  threshold：扩容的阈值，等于 capacity * loadFactor

  Java8引入了红黑树，当链表中的元素超过了 8 个以后， 会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)

## 16.Java的自动拆装箱

- 装箱：把基本数据类型转换成包装类的过程
- 拆箱：把包装类转换成基本数据类型的过程

**自动拆装箱的问题：**

- 包装对象进行比较时，==比较的是地址，equals方法比较的是值
- 如果包装类对象为null，那么自动拆箱时就可能抛出空指针异常
- 如果在一个for循环中有大量的拆装箱操作，会浪费很多资源

**缓存机制：**

```java
public class Main {
    public static void main(String[] args) {
        Integer a = 3;      //整数3自动装箱
        Integer b = 3;      //整数3自动装箱
        System.out.println(a == b);         //true

        Integer c = 128;    //整数128自动装箱
        Integer d = 128;    //整数128自动装箱
        System.out.println(c == d);         //false
    }
}
```

从Java5开始提供了**缓存机制**——**编译特性**。Integer缓存数组中默认保存-128~127的值的包装类对象。其中后面的127数值可以通过**JVM参数** ` -XX :AutoBoxCacheMax=size`  进行修改(JVM调优常用配置 )。这个参数只对Integer有效，Long无法调节。

缓存范围：

- Boolean：(全部缓存)
- Byte：(全部缓存)
- Character：(0 — 127缓存)
- Short：(-128 — 127缓存)
- Long：(-128 — 127缓存)
- Integer：(-128 — 127缓存)
- Float：(没有缓存)
- Doulbe：(没有缓存)

面试题1：java 是否存在使得语句 i > j || i <= j 结果为 false 的 i、j 值？

答：存在。java 的数值 NaN 代表 not a number，无法用于比较。

```java
i = Double.NaN;
j = i;
System.out.println(i == j); //false
```

面试题2：`Integer i=1; i += 1;`做了哪些事情？

答：首先 `Integer i=1;`进行了自动装箱，使用 valueOf() 方法将 int  装箱成 Integer 类型；

接着 `i += 1;` 将 i 自动拆箱，完成加法运行后在进行装箱。

## 17.线程池使用？常用参数和创建方法

线程池的优势：

- 降低资源消耗
- 提高响应速度
- 提高线程的可管理性
- 提供更多更强大的功能，具备可拓展性。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行

线程池的创建方法分为两类：

- 通过 ThreadPoolExecutor 创建线程池
- 通过 Executors 创建的线程池

具体创建方法分为7种：

- Executors.newFixedThreadPool：创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待；
- Executors.newCachedThreadPool：创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程；
- Executors.newSingleThreadExecutor：创建单个线程数的线程池，它可以保证先进先出的执行顺序；
- Executors.newScheduledThreadPool：创建一个可以执行延迟任务的线程池
- Executors.newSingleThreadScheduledExecutor：创建一个单线程的可以执行延迟任务的线程池；
- Executors.newWorkStealingPool：创建一个抢占式执行的线程池（任务执行顺序不确定）【JDK 1.8 添加】。
- ThreadPoolExecutor：最原始的创建线程池的方式，它包含了 7 个参数可供设置。

如何选用？

Executors 返回的线程池对象弊端:

1） FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。

2）CachedThreadPool：允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。

推荐使用 ThreadPoolExecutor 的方式进行线程池的创建，因为这种创建方式更可控，并且更加明确了线程池的运行规则，可以规避一些未知的风险。

```java
 public ThreadPoolExecutor(int corePoolSize, //核心线程数，始终存活的线程数
                           int maximumPoolSize, //最大线程数
                           long keepAliveTime, //线程存活时间，线程中没有任务执行时最大线程就会销毁一部分
                           TimeUnit unit, //配合keepAliveTime使用，时间单位
                           //阻塞队列，存储线程池等待执行的任务，线程安全
                           BlockingQueue<Runnable> workQueue,
                           //线程工厂，主要用来创建线程，默认为正常优先级、非守护线程
                           ThreadFactory threadFactory,
                           //拒绝策略
                           RejectedExecutionHandler handler) {
     // 省略...
 }
```

- 阻塞队列选用

  比较常用的是 `LinkedBlockingQueue` 和 `SynchronousQueue`
- 拒绝策略选用

  > 包括以下四种：
  >
  > 1、AbortPolicy：拒绝并抛出异常
  >
  > 2、CallerRunsPolicy：使用当前调用的线程来执行任务
  >
  > 3、DiscardOldestPolicy：抛弃队列头部（最旧）的一个任务，并执行当前任务
  >
  > 4、DiscardPolicy：忽略并抛弃当前任务
  >
  > 默认是 `AbortPolicy`，支持自定义
  >

## 18.常见排序算法时间复杂度？

## 19.Collection和Collections的作用

- java.util.Collection 是一个集合框架的父接口，Set、List 都实现了该接口，提供了对集合对象进行基本操作的通用接口方法
- Collections 是一个包装类，包含各种有关集合操作的静态方法，包含对集合的排序、搜索以及序列化等。不能实例化，是一个工具类

## 20.GC垃圾回收算法了解多少？

GC最基础的算法有三种： 标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。

- 标记 -清除算法，“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。
- 复制算法，“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
- 标记-压缩算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清 理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存分代收集算法，
- 分代收集（Generational Collection）算法，把Java堆分为新生代和老年代，这 样就可以根据各个年代的特点采用最适当的收集算法。

## 21.Mysql如何调优？

- 1、查询语句中不要使用select *
- 2、尽量减少子查询，使用关联查询（left join,right join,inner join）替代
- 3、减少使用IN或者NOT IN ,使用exists，not exists或者关联查询语句替代
- 4、or 的查询尽量用 union或者union all 代替(在确认没有重复数据或者不用剔除重复数据时，union all会更好)
- 5、应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。
- 6、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫 描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null 值，然后这样查询： select id from t where num=0

## 22.事务的底层原理？

## 23.讲讲Java的锁

[java锁面试](https://blog.csdn.net/java_cch/article/details/118381485)

Java中锁的实现方式有两种，synchronized关键字和并发包中的锁类。

几种关于锁的概念：

- 死锁：线程之间相互等待着对方释放资源，而自己的资源又不释放
- 重入锁：一个线程在拥有了当前资源的锁之后，可以再次拿到锁而不被阻塞
- 自旋锁：
- 自适应自旋锁：

## 24.讲讲对IOC和AOP的理解

- IOC就是Spring提供的一种容器管理技术，通过依赖注入的方式使编程时无需手动实例化，我们可以使用核心注解@Autowired和@Resource进行自动装配，还可以使用@Value注解注入属性值
- AOP是面向切面编程，简单地说就是可以在方法执行前后使用动态代理技术加上需要的逻辑。如果实现了接口，Spring会使用JDK的动态代理，否则使用CGLib动态代理。常用场景包括权限认证、自动缓存、错误处理、日志、调试和事务等。

  AOP的相关注解有：

  > @Aspect：声明被注解的类是一个切面Bean
  >
  > @Before：前置通知
  >
  > @After：后置通知（不论正常返回还是异常退出）
  >
  > @AfterReturnning：返回后通知，正常完成后执行的通知，返回值使用returnning属性接收
  >
  > @AfterThrowing：异常通知，异常使用throwing属性接收
  >

参考原文：[面试必问的Spring IoC与Spring AOP面试题](https://blog.csdn.net/weixin_48182198/article/details/107593961)

## 25.Redis为什么这么快？Redis的IO模型了解嘛

Redis的QPS可达到10万/每秒，共有以下五点原因：

- 基于内存实现——对比MySQL磁盘数据库
- 高效的数据结构
- 使用了合理的数据编码
- 合理的线程模型

  Redis是单线程模型，有效避免了上下文的切换，同时使用了IO多路复用技术
- 虚拟内存机制

  暂时把冷数据放到磁盘，从而腾出了宝贵的内存空间，通过VM机制实现了冷热数据分离，避免因为内存不足而造成访问速度下降

Redis的I/O多路复用模型有效地解决了单线程的服务端，使用不阻塞的方式处理多个client端请求问题。

多路指的是多个网络连接客户端，这个模型使用了一个线程检查多个Socket的就绪状态，从而管理多个IO流，

## 26.Spring用到了哪些设计模式

- 控制翻转（IoC原则）和 **依赖注入**（Dependcy Inject)
- **工厂设计模式**：Spring使用工厂模式可以通过 `BeanFactory` 或 `ApplicationContext` 创建 bean 对象
- **单例设计模式**：Spring 中 bean 的默认作用域就是 **singleton**(单例)的
- **代理设计模式**：AOP切面编程就是基于**动态代理**的
- **模板方法模式**：是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。例如JDBCTemplate。
- **观察者模式**：是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。Spring **事件驱动模型**就是观察者模式很经典的一个应用。
- **适配器模式**：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。
- **装饰器模式**：可以动态地给对象添加一些额外的属性或行为。相比于使用继承，装饰者模式更加灵活。

## 27.有一张表，对a、b、c三个字段建立联合索引，问只对a、b where查找，能命中吗？

mysql 建立多列索引（联合索引）有**最左前缀**的原则，即**最左优先**，如：

- 如果有一个 2 列的索引 (col1, col2)，则已经对 (col1)、(col1, col2) 上建立了索引；
- 如果有一个 3 列索引 (col1, col2, col3)，则已经对 (col1)、(col1, col2)、(col1, col2, col3) 上建立了索引；

`select  * from [table] where A = 1 and B = 3`

上面这个sql语句执行后，数据库系统可以直接从索引文件中直接二分法找到 A = 1 的记录，然后再 B = 3 的记录

但如果是 where B = 3 则需要遍历这个索引表的全部

注意：

- 如果查询条件中含有函数或者表达式，将导致索引失效而进行全表查询
- 如果查询条件中有两个范围列则无法全用到索引
- like "value%"可以使用索引，like "%value%" 不会使用索引，走的是全表扫描
- 索引不会包含NULL值的列，联合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的

## 28.Mybatis中 # 和 $ 的区别

- 使用\#{}的方式可以很大程度防止sql注入，而 ${} 无法防止sql注入
- 使用\${}会将传入的数据直接显示生成在sql中，而\#{}将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。所以在JDBC能使用占位符的地方，最好优先使用\#{}，否则用${}

  典型情况就是**动态参数**

  ```xml
  -- 动态指定表名
  <select>
        select *  from emp_ ${year}
  </select>

  -- 排序时使用 order by动态参数
  <select>
         select  *  from dept order by ${name}
  </select>
  ```
- 模糊查询

  ```xml
  <select id="findUserByName" parameterType="String" resultMap="studentResultMap">
          SELECT * FROM user WHERE username LIKE '%${value}%'
  </select>

  <select id="findUserByName" parameterType="String" resultMap="studentResultMap">
          SELECT * FROM USER WHERE username LIKE CONCAT('%', #{username}, '%')
  </select>
  ```

## 29.@RestController和@Controller的区别

  @RestController注解等价于@ResponseBody ＋ @Controller

- **共同点**：都用来表示Spring某个类是否可以接收HTTP请求
- **二者区别： @RestController无法返回指定页面，而@Controller可以**；如果需要返回JSON，XML或自定义mediaType内容到页面，@RestController自己就可以搞定，这个注解对于返回数据比较方便，因为它**会自动将对象实体转换为JSON格式**。而@Controller需要在对应的方法加上@ResponseBody注解。

## 30.Spring如何解决循环依赖？

[什么是Spring的循环依赖](https://blog.csdn.net/Candyz7/article/details/126776789?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~AD_ESQUERY~yljh-2-126776789-blog-119222944.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~AD_ESQUERY~yljh-2-126776789-blog-119222944.pc_relevant_aa&utm_relevant_index=3)

## 31.将List转为String有几种方式？

- 循环遍历List进行字符串拼接
- 利用join方法：String.join("," , list);
- 利用StringUtils的join方法：StringUtils.join(list, ",");
- 利用stream流：list.stream().collect(Collectors.joining(","));

## 32.@Transactional注解的使用

- 该注解只能用在public 方法上，如果用在protected或者private的方法上，不会报错，但是该注解不会生效
- 只能回滚非检查型异常，具体为RuntimeException及其子类和Error子类
- 使用rollbackFor 属性来定义回滚的异常类型，使用 propagation 属性定义事务的传播行为

  ```java
   @Transactional(rollbackFor = Exception.class,propagation = Propagation.REQUIRED)
  ```
- 不能回滚被try{}catch() 捕获的异常
- 只能对在被Spring 容器扫描到的类下的方法生效

**事务传播规则：**

| PROPAGATION_REQUIRED                | 支持当前事务，如果当前没有事务，则创建一个事务，这是最常见的选择                                            |
| ----------------------------------- | ----------------------------------------------------------------------------------------------------------- |
| **PROPAGATION_SUPPORTS**      | **支持当前事务，如果当前没有事务，就以非事务来执行**                                                  |
| **PROPAGATION_MANDATORY**     | **支持当前事务，如果没有当前事务，就抛出异常**                                                        |
| **PROPAGATION_REQUIRES_NEW**  | **新建事务，如果当前存在事务，就把当前事务挂起**                                                      |
| **PROPAGATION_NOT_SUPPORTED** | **以非事务执行操作，如果当前存在事务，则当前事务挂起**                                                |
| **PROPAGATION_NEVER**         | **以非事务方式执行，如果当前存在事务，则抛出异常**                                                    |
| **PROPAGATION_NESTED**        | **如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED 类似的操作。** |

事务隔离级别，使用isolation属性进行配置：

- Isolation.READ_UNCOMMITTED：读取未提交数据(会出现脏读, 不可重复读) 基本不使用
- Isolation.READ_COMMITTED：读取已提交数据(会出现不可重复读和幻读)
- Isolation.REPEATABLE_READ：可重复读(会出现幻读)
- Isolation.SERIALIZABLE：串行化

MySQL默认使用的隔离级别为REPEATABLE_READ

## 33.多态的应用场景

多态——把子类对象伪装成父类对象

- 定义方法参数列表时，定义为父类类型，这样就可以传递任意子类类型的对象
- 定义成员变量时，定义为父类类型，这样就可以赋值任意子类类型的对象
- 定义方法返回值类型时，定义为父类类型，这样就可以返回任意子类类型的对象
- 定义数组元素类型时，定义为父类类型，这样就可以装任意子类类型的对象

好处：

- 增强了代码的复用性
- 增强了类的扩展性
- 降低了耦合性

## 34.类加载机制

[两道面试题，带你解析Java类加载机制 - 陈树义 - 博客园 (cnblogs.com)](https://www.cnblogs.com/chanshuyi/p/the_java_class_load_mechamism.html)

类加载过程主要包含加载、验证、准备、解析、初始化、使用、卸载七个方面

## 35.GC什么时候触发？哪些可以作为GC root? Java GC后还会有内存泄露的问题吗？

- GC分为 minor GC 和 Full GC
- Java堆从GC的角度又分为**新生代**（eden、from survivor、to survivor）、**老年代**(在Java8中，`永久代已经被移除，`被一个称为**“元数据区”**（元空间）的区域所取代)

`<font color="red">`GC触发条件：`</font>`

1、在程序空闲时。

2、程序不可预知的时候/手动调用 System.gc() 。不要手动调用GC，不管是 JVM 自己调用还是手动调用都会使系统陷入短暂的停顿，给垃圾回收让路，手动调用就违背了我们优化 GC 的初衷了

3、堆内存不足时 GC 会被调用。当应用线程在运行，并在运行过程中穿件对象，若这时内存空间不足，JVM就会强制的调用 GC ，一遍回收内存用于新的分配。若GC 一次之后仍不满足内存分配的要求，JVM会再次进行两次 GC 做进一步尝试，若还是不满足需求则会抛出 “out of memort” 的错误使应用异常停止

> 轻GC的触发条件：多数情况下，直接在 Eden 区中进行分配。如果 Eden区域没有足够的空间，那么就会发起一次 Minor GC
>
> 重GC的触发条件：如果老年代没有足够空间的话，那么就会进行一次 Full GC

`<font color="red">`Java什么时候会发生内存泄漏：`</font>`

```

	1、静态集合类，如 HashMap、Vector 等，因为GC是不会回收静态类的
    2、各种连接，如 数据库连接、网络连接、IO连接等如果没有调用 close 关闭，GC不会回收导致的内存泄露，所以我们一再强调使用完连接之后一定要在  finally 中关闭
    3、强引用，Object obj = new Object()  这种使用 new 方式创建的就属于强引用，（如果有GCRoots的强引用）垃圾回收器绝对不会回收它，当内存不足时宁愿抛出 OOM 错误使得程序异常停止也不会回收强引用对象
    4、监听器的使用，在释放内存的同时没有相应删除监听器的时候也可能导致内存泄露

```

`<font color="red">`GC是怎样判断对象存活的：`</font>`

```
 - 可达性分析（Java中使用）
这个算法的基本思路就是通过一系列的称为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GCRoots没有任何引用链相连时，则证明此对象是不可用的。
```

`<font color="red">` 作为 GC Roots 的对象包括下面几种：`</font>`

```
当前虚拟机栈中局部变量表中的引用对象
当前本地方法栈中局部变量中的引用的对象
方法区中类静态属性引用的对象
方法区中常量引用的对象
```

## 36. 反射机制

## 37.HTTP和HTTPS的区别？

- HTTPS  协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。
- HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 **SSL 加密传输协议**。
- HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
- HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)

## 38.多线程共享变量问题（ThreadLocal）

- **volatile**变量每次被线程访问时，都强迫线程从主内存中重读该变量的最新值，而当该变量发生修改变化时，也会强迫线程将最新的值刷新回主内存中。这样一来，不同的线程都能及时的看到该变量的最新值。但是volatile**不能保证变量更改的原子性**

  适用于：

  - 对变量的写入操作不依赖当前值
  - 当前volatile变量不依赖于别的volatile变量
- 对自增之类的非原子性操作想要保证可见性，可以使用

  1、加锁：synchronized或者ReentantLock

  2、使用原子类：AtomicInteger
- **ThreadLoacl**

  参考：[Java并发-ThreadLocal的使用](https://blog.csdn.net/abc123mma/article/details/128060530)

  > 1、当使用 ThreadLocal 维护变量时，ThreadLocal 为每个使用该变量的线程提供**独立的变量副本**，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。可以避免线程安全问题。
  >
  > 2、ThreadLocal 是线程本地存储，在每个线程中都创建了一个 **ThreadLocalMap** 对象，每个线程可以访问自己内部 ThreadLocalMap 对象内的 value。通过这种方式，避免资源在多线程间共享
  >

  ```java
  public class ThreadLocalTest {
      static ThreadLocal<String> local = new ThreadLocal<>();
      public static void main(String[] args) {

          Thread threadA = new Thread(()->{
              local.set("线程One-在里面设置值了");
              try {
                  Thread.sleep(5000);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
              System.out.println(local.get());
          });
          threadA.setName("ThreadOne");

          Thread threadB = new Thread(()->{
              local.set("线程Two-在里面设置值了");
              System.out.println(local.get());
              local.remove();
          });
          threadB.setName("ThreadTwo");

          threadA.start();
          threadB.start();
      }
  }
  ```

  threadA调用set方法并休眠5秒后进行打印变量值，threadB调用set方法立即打印并且remove。最终结果两个线程没有互相干涉，都正常输出。

  缺点：ThreadLocal维护的变量**只能设置一个值，再次调用set方法时会覆盖**。

## 39.ConcurrentHashMap如何保证线程安全（分段锁）？

- 底层采用分段的数组+链表实现，**线程安全**
- 通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。(读操作不加锁，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。)
- Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术
- 有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁
- 扩容：段内扩容（段内元素超过该段对应Entry数组长度的75%触发扩容，不会对整个Map进行扩容），插入前检测需不需要扩容，有效避免无效扩容

**锁分段技术**：首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。

ConcurrentHashMap默认将hash表分为16个桶，诸如get、put、remove等常用操作只锁住当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有16个写线程执行，并发性能的提升是显而易见的。

## 40.讲讲CAS和Synchronized的区别、

参考：[面试被问CAS和Synchronized的区别](https://zhuanlan.zhihu.com/p/134085332)

CAS（Compare And Swap ）是乐观锁的一种实现方式，是一种`<mark>`轻量级锁`</mark>`。JAVA1.5开始引入了CAS，JUC下很多工具类都是基于CAS。

CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。当多个线程同时尝试使用CAS更新一个变量时，任何时候只有一个线程可以更新成功，若更新失败，线程会重新进入循环再次进行尝试。

CAS在Java中的应用：

主要依赖于**Unsafe**的CAS操作来进行实现，可能会出现自旋问题，CPU压力很大，可以使用版本号机制解决ABA问题

相比于CAS基于乐观锁实现，**synchronized **是基于`<mark>`悲观锁`</mark>`的，当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。

## 41.为什么HashMap不用B树？为什么InnoDB索引不用红黑树？

HashMap 如果用B/B+树的话，在数据量不是很多的情况下，数据都会“挤在”一个结点里面，这个时候遍历效率就退化成了链表。

[漫画：什么是B+树？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/54102723)

B树是一种磁盘友好型的数据结构，树的高度是可控的，一般比较矮胖，树的高度可以大致上看成磁盘IO的次数，

B+树也是一种平衡树，但是它的叉是可动态指定的，在Mysql中大约是1170。因为叉的数量足够多，所以在同等数量级下，树高更低。通过增加单个节点中关键字的数量，来降低树高，这种结构更适合磁盘。

**B+树的优势：**

1.单一节点存储更多的元素，使得查询的IO次数更少。

2.所有查询都要查找到叶子节点，查询性能稳定。

3.所有叶子节点形成有序链表，便于范围查询。

## 42.如何保证分布式事务？分布式事务如何回滚？

事务的ACID特性：

- 原子性(Atomicity)：操作过程不可分割,要么都成功，要么都失败
- 一致性(Consistency)：指在数据库操作前后是完全一致的。这个一致可以理解为对数据库操作的有效性
- 隔离性(Isolation)：多个事物可以同时进行且彼此之间无法访问。只有在事物完成最终的操作的时候，才可以看见结果。这种主要涉及到数据的脏读，幻读等问题。
- 持久性(Durability)：已被提交的事务对数据库的修改应该永久保存在数据库中

事务的隔离级别：

| 隔离级别        | 值 | 导致的问题                                                   |
| --------------- | -- | ------------------------------------------------------------ |
| Read-Uncommited | 0  | 导致脏读                                                     |
| Read-Commited   | 1  | 避免脏读，允许不可重复读和幻读                               |
| Repeatable-Read | 2  | MySQL默认隔离级别。避免脏读和不可重复读，允许幻读            |
| Serializable    | 3  | 串行化读，事务只能一个一个地执行，但是执行效率较慢，慎重使用 |

- 脏读（Read Uncommited）：读到了其他事务未提交的数据
- 不可重复读（Non-repeatable Read）：多次查询到的数据不一致，读取到的是已提交的数据
- 幻读（Phantom Read）：指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录
  时，会产生幻行。幻读只能通过Serializable隔离级别来实现

[Spring事务和MySQL事务](https://blog.csdn.net/weixin_48272905/article/details/108525283)

[如何保证分布式事务](https://blog.csdn.net/Huang_ZX_259/article/details/128375673)

## 43.讲讲ThreadLocal为什么会发生内存泄漏？

在每一个线程Thread对象中，都维护了一个**ThreadLocalMap** 对象

**ThreaLocal本身是不存储值的，我们在使用其对应的set、get方法时，都是操作的其对应的ThreadLocalMap对象**

在ThreadLocalMap的Entry中的**key**存储的是ThreadLocal的**弱引用**，**value**存储的是对象的**强引用**

**弱引用在发生GC时，就会被垃圾回收掉**

所以，在当前线程正在运行的时候，发生GC时，在ThreadLocal对象没有被其它地方强引用时，key指向ThreadLocal的虚引用就会立即断开（被垃圾回收掉），这时，就会出现ThreadLocalMap中存在key为null的Entry，只要当前线程不结束，该ThreadLocalMap对象就会一直存在，永远无法回收，因为此时还存在一条强引用的链路

**Entry对象的key为什么要使用弱引用，有什么好处？**

假设如果存储的强引用，将ThreadLocal置为空，那我们断开ThreadLocal Reference —> ThreadLocal的引用，会发现key强引用了ThreadLocal，导致该对象永远无法被GC。

## 44.Java序列化的理解？如何深拷贝？

[面试官：Java序列化为什么要实现Serializable接口？](https://zhuanlan.zhihu.com/p/340258358)

序列化是指把**`<mark>`对象的状态信息`</mark>`**转化为可存储或可传输的形式的过程（并不是保存类的状态，所以静态变量不会被序列化）

- 如何控制某个变量不被序列化？

  在变量声明前加上 `Transient` 关键字，在被反序列化后，transient变量的值设为初始值，如int型的是0
- serialVersionUID有什么作用？

  Java的序列化机制是通过判断类的 serialVersionUID 来验证版本一致性的。在进行反序列化时，JVM 会把传来的字节流中的 serialVersionUID与本地相应实体类的 serialVersionUID 进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即是 InvalidCastException。

  如果没有为指定的 class 配置 serialVersionUID，那么 java 编译器会自动给这个 class 进行一个摘要算法，类似于指纹算法，只要这个文件有任何改动，得到的 UID 就会截然不同的，可以保证在这么多类中，这个编号是唯一的。

  serialVersionUID有两种生成方式：

  (1) 默认的1L,比如：private static final long serialVersionUID = 1L;

  (2) 根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段
- 如何实现深拷贝？

  在java中存在一个Cloneable接口，通过实现这个接口的类都会具备clone的能力，同时clone在内存中进行，在性能方面会比我们直接通过new生成对象要高一些，特别是一些大的对象的生成，性能提升相对比较明显。我们可以使类实现 `Cloneabel` 接口，然后重写clone方法实现深拷贝。深拷贝时只要调用该类的clone方法即可，如果类中的属性不是基础数据类型，对这个属性类也要进行同样的操作实现深拷贝。

## 50.MySQL 的 count(*) 如何优化？

首先要判断有没有加where条件，不加where条件的count(*)在不同的数据库引擎下有不同的实现：

- MyISAM引擎，会将表的总行数记录在磁盘上，因此count(*)会直接返回个数，效率较高
- InnoDB引擎，则是需要一行一行的从引擎中读出来，然后累计计数。因为要支持事务并发查询，返回的行数是不确定的

InnoDB是`<mark>`索引组织表`</mark>`，所有的数据都是通过B+树的方式组织起来的，**主键索引的叶子节点是整行数据**，**普通索引(二级索引)的叶子节点是主键值**，因此**普通索引树的大小要比主键索引树小的多**。对于count(*)，MySQL优化器会找到最小的那棵索引树然后进行遍历。

如果某张大表需要经常性的进行count(*)操作，可以考虑**单独建立一张表**进行保存大表的记录行数。

**count性能比较**

1. count(primary key)：遍历整个表，把**主键值拿出来，累加**；
2. count(1)：遍历整个表，但是**不取值，累加**；
3. count(非空字段)：遍历整个表，读出这个**字段，累加**；
4. count(可以为空的字段)：遍历整个表，读出这个字段，**判断不为null累加**；
5. count(*)：遍历整个表，做了优化，**不取值，累加**。

结论：count(字段) < count(primary key)  < count(1) ≈ count(*)

推荐直接使用count(*）

带条件查询主要是要避免全表扫描，在查询字段上建立索引是比较好的解决办法。另外，查询条件应该尽量避免 `group by`，大规模数据分页查询limit的优化等。

## 51.MySQL大规模数据的分页慢查询如何优化？

参考：https://blog.csdn.net/u013190417/article/details/126132668

对于 `select * from table order by id limit offset, n` 这样的分页查询sql，经过实验表明随着起始位置 `offset` 的增大，分页查询的效率成倍下降，当起点位置在 百万 以上的时候，对于百万级数据体量的单表，查询耗时基本上以秒为单位。而事实上，**一般查询耗时超过 1 秒的 SQL 都被称为慢 SQL**。

原因：MySQL在执行这样的分页查询语句时，并不是从起始位置开始查询，而是取 `offset + N`行数据，最后放弃前offset条记录，只返回N行。在进行大规模数据分页查询时，如果起始位置很大，效率自然非常低下。

优化方案：

1、查询时只返回主键ID，避免 `select *`，改成 `select id` （起始位置百万时，查询100条记录约500ms）

通过这种方式查询到 `id`后再通过 `id`查询部分数据即可：`select * from table where id in ()`

2、查询时通过主键ID过滤，这个方案**要求主键ID必须是数字类型**，实践的思路就是取上一次查询结果的 ID 最大值，作为过滤条件，而且排序字段必须是主键 ID，不然分页排序顺序会错乱。

`select * from table_name where id > 1000000 order by id limit 100`

3、采用ElasticSearch作为搜索引擎

当数据量越来越大的时候，尤其是出现分库分表的数据库，以上通过主键 ID 进行过滤查询，效果可能会不尽人意，例如订单数据的查询，**这个时候比较好的解决办法就是将订单数据存储到 ElasticSearch 中**，通过 ElasticSearch 实现快速分页和搜索，效果提升也是非常明显。

## 52.Redis的过期删除策略和内存淘汰策略

[Redis详解（十一）------ 过期删除策略和内存淘汰策略 - YSOcean - 博客园 (cnblogs.com)](https://www.cnblogs.com/ysocean/p/12422635.html)
