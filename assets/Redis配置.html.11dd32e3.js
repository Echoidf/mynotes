import{_ as e}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as a,c as s,b as n}from"./app.161d159c.js";const i={},t=n(`<h2 id="一、常规配置" tabindex="-1"><a class="header-anchor" href="#一、常规配置" aria-hidden="true">#</a> 一、常规配置</h2><h3 id="_1-设置密码" tabindex="-1"><a class="header-anchor" href="#_1-设置密码" aria-hidden="true">#</a> 1.设置密码</h3><h4 id="a-永久设置-通过配置文件" tabindex="-1"><a class="header-anchor" href="#a-永久设置-通过配置文件" aria-hidden="true">#</a> a.永久设置--通过配置文件</h4><p><img src="https://s2.loli.net/2023/01/28/46wJHmdVPulz7EW.png" alt="20230128113221"></p><p>requirepass配置可以让用户使用AUTH命令来认证密码，才能使用其他命令。</p><p>使用requirepass的时候需要注意，因为redis太快了，每秒可以认证15w次密码，简单的密码很容易被攻破，所以最好使用一个更复杂的密码</p><h4 id="b-命令行设置" tabindex="-1"><a class="header-anchor" href="#b-命令行设置" aria-hidden="true">#</a> b.命令行设置</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> config <span class="token builtin class-name">set</span> requirepass zql  <span class="token comment">#设置密码</span>
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> config get requirepass
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;requirepass&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;zql&quot;</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> key val
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get key
<span class="token string">&quot;val&quot;</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> quit
zql@Master:/opt/Redis/redis-6.2.6$ redis-cli  <span class="token comment">#重新登录客户端</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get key
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> NOAUTH Authentication required.	      <span class="token comment">#此时需要进行密码认证</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> auth zql		      <span class="token comment">#输入密码</span>
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get key			      <span class="token comment">#可以进行操作了</span>
<span class="token string">&quot;val&quot;</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-daemonize" tabindex="-1"><a class="header-anchor" href="#_2-daemonize" aria-hidden="true">#</a> 2.daemonize</h3><p>是否在后台执行，yes：后台运行；no：不是后台运行</p><h3 id="_3-loglevel" tabindex="-1"><a class="header-anchor" href="#_3-loglevel" aria-hidden="true">#</a> 3.loglevel</h3><p>指定了服务端日志的级别。</p><p>级别包括：</p><ul><li>debug（很多信息，方便开发、测试）</li><li>verbose（许多有用的信息，但是没有debug级别信息多）</li><li>notice（适当的日志级别，适合生产环境）</li><li>warn（只有非常重要的信息）</li></ul><h3 id="_4-logfile" tabindex="-1"><a class="header-anchor" href="#_4-logfile" aria-hidden="true">#</a> 4.logfile</h3><p>指定了记录日志的文件。空字符串的话，日志会打印到标准输出设备。后台运行的redis标准输出是/dev/null</p><h3 id="_5-设定库的数量" tabindex="-1"><a class="header-anchor" href="#_5-设定库的数量" aria-hidden="true">#</a> 5.设定库的数量</h3><p>默认：<code>database 16</code></p><p>默认使用的数据库是0。可以通过”SELECT 【数据库序号】“命令选择一个数据库，序号从0开始</p><h2 id="二、units单位" tabindex="-1"><a class="header-anchor" href="#二、units单位" aria-hidden="true">#</a> 二、Units单位</h2><p>配置文件中说明了基本的度量单位，只支持bytes，不支持bit【注意：1k=1000bytes】</p><p><img src="https://s2.loli.net/2023/01/28/EPnL4KCWzYMGF7x.png" alt="20230128111728"></p><h2 id="三、-includes" tabindex="-1"><a class="header-anchor" href="#三、-includes" aria-hidden="true">#</a> 三、#INCLUDES#</h2><p>多实例的情况下可以把公用的配置文件提取出来，然后include</p><p><img src="https://s2.loli.net/2023/01/28/lC6dnJ9AqsNPVri.png" alt="20230128112110"></p><h2 id="四、-network" tabindex="-1"><a class="header-anchor" href="#四、-network" aria-hidden="true">#</a> 四、#NETWORK#</h2><h3 id="_1-bind" tabindex="-1"><a class="header-anchor" href="#_1-bind" aria-hidden="true">#</a> 1.bind</h3><ul><li>默认情况bind=127.0.0.1只能接受本机的访问请求</li><li>如果需要远程访问，需要注释掉该行</li></ul><h3 id="_2-protected-mode" tabindex="-1"><a class="header-anchor" href="#_2-protected-mode" aria-hidden="true">#</a> 2.protected-mode</h3><ul><li>默认是保护模式 <code>protected-mode yes</code></li><li>如果需要远程访问，需要改为no</li></ul><h3 id="_3-port" tabindex="-1"><a class="header-anchor" href="#_3-port" aria-hidden="true">#</a> 3.port</h3><p>默认端口 <code>port 6379</code></p><h3 id="_4-timeout" tabindex="-1"><a class="header-anchor" href="#_4-timeout" aria-hidden="true">#</a> 4.timeout</h3><p>默认 <code>timeout 0</code></p><p>一个空闲的客户端维持多少秒会关闭，0 表示关闭该功能, 即永不超时</p><h3 id="_5-tcp-keepalive" tabindex="-1"><a class="header-anchor" href="#_5-tcp-keepalive" aria-hidden="true">#</a> 5.tcp-keepalive</h3><p>默认 <code>tcp-keepalive 300</code></p><p>tcp-keepalive 是对访问客户端的一种心跳检测，每隔 n 秒检测一次, 单位为秒</p><p>如果设置为 0，则不会进行 Keepalive 检测，建议设置成 60</p><h3 id="思考" tabindex="-1"><a class="header-anchor" href="#思考" aria-hidden="true">#</a> 思考</h3><p><strong>为什么需要心跳检测机制？</strong></p><ol><li>TCP 协议中有长连接和短连接之分。短连接环境下，数据交互完毕后，主动释放连接；</li><li>长连接的环境下，进行一次数据交互后，很长一段时间内无数据交互时，客户端可能意外断开，这些 TCP 连接并未来得及正常释放，那么，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，且有可能导致在一个无效的数据链路层面发送业务数据，结果就是发送失败。所以服务器端要做到快速感知失败，减少无效链接操作，这就有了 TCP 的 Keepalive(保活探测)机制。</li></ol><h2 id="五、-limits限制" tabindex="-1"><a class="header-anchor" href="#五、-limits限制" aria-hidden="true">#</a> 五、#LIMITS限制#</h2><h3 id="_1-maxclients" tabindex="-1"><a class="header-anchor" href="#_1-maxclients" aria-hidden="true">#</a> 1.maxclients</h3><p>设置 redis 同时可以与多少个客户端进行连接</p><p>默认：<code>maxclients 10000</code></p><h3 id="_2-maxmemory" tabindex="-1"><a class="header-anchor" href="#_2-maxmemory" aria-hidden="true">#</a> 2.maxmemory</h3><p>默认：<code># maxmemory &lt;bytes&gt;</code>，在默认情况下, 对于 64 位实例没有限制，对 32 位 实例会限制在 3 GB, 因为 32 位的机器最大只支持 4GB 的内存，可以避免因为内存不足而导致 Redis 实例崩溃</p><p>当用户开启了 redis.conf 配置文件的 maxmemory 选项，那么 Redis 将限制选项的值不能小于 1 MB</p><p><strong>建议</strong>：</p><ul><li>设置取决于使用情况, 有些网站只需要 32MB，有些可能需要 12GB。只能根据具体的生产环境来调试，不要预设一个定值，从小到大测试，基本标准是不干扰正常程序的运行</li><li>最大使用内存跟搭配方式有关，如果只是用 Redis 做纯缓存, 64-128M 对一般小型网站就足够了</li><li>如果使用 Redis 做数据库的话，设置到物理内存的 1/2 到 3/4 左右都可以</li><li>如果使用了快照功能的话，最好用到 50%以下，因为快照复制更新需要双倍内存空间，如果没有使用快照而设置 redis 缓存数据库，可以用到内存的 80%左右，只要能保证 Java、NGINX 等其它程序可以正常运行就行了</li></ul><h3 id="_3-maxmemory-policy" tabindex="-1"><a class="header-anchor" href="#_3-maxmemory-policy" aria-hidden="true">#</a> 3.maxmemory-policy</h3><p>默认：<code># maxmemory-policy noeviction</code></p><p><strong>policy一览</strong></p><ol><li>volatile-lru：使用 LRU 算法移除 key，只对设置了过期时间的键；(最近最少使用)</li><li>allkeys-lru：在所有集合 key 中，使用 LRU 算法移除 key</li><li>volatile-random：在过期集合中移除随机的 key，只对设置了过期时间的键</li><li>allkeys-random：在所有集合 key 中，移除随机的 key</li><li>volatile-ttl：移除那些 TTL 值最小的 key，即那些最近要过期的 key</li><li>noeviction：不进行移除。针对写操作，只是返回错误信息</li></ol><h3 id="_4-maxmemory-samples" tabindex="-1"><a class="header-anchor" href="#_4-maxmemory-samples" aria-hidden="true">#</a> 4.maxmemory-samples</h3><p>默认：<code># maxmemory-samples 5</code></p><ul><li>设置样本数量，LRU 算法和最小 TTL 算法都并非是精确的算法，而是估算值，所以可以设置样本的大小，redis 默认会检查这么多个 key 并选择其中 LRU 的那个</li><li>一般设置 3 到 7 的数字，数值越小样本越不准确，但性能消耗越小</li></ul>`,58),r=[t];function l(o,d){return a(),s("div",null,r)}const h=e(i,[["render",l],["__file","Redis配置.html.vue"]]);export{h as default};
