const t=JSON.parse('{"key":"v-ec77bb50","path":"/codenotes/graphql/introspection.html","title":"GraphQL 内省","lang":"zh-CN","frontmatter":{"title":"GraphQL 内省","metaTitle":"GraphQL 内省 | GraphQL 教程","metaDescription":"了解什么是 GraphQL 内省，以及它如何有助于开发类似 GraphiQL 的社群工具。","icon":"storage","category":["GraphQL"],"tag":["GraphQL"],"sticky":false,"star":false,"article":false,"timeline":true,"description":"与 REST 相比，赋予 GraphQL 众多优势的一个主要功能是“内省”。 GraphQL 查询语言是强类型的。 这种强类型系统提供了查询和理解潜在模式的能力。 模式充当前端和后端团队之间的契约。 但前端开发者如何了解后端模式是怎样的？ 他们如何防止过度抓取或不足抓取？ 这可能是由于“内省”查询。 内省查询 {#introspection-queri...","head":[["meta",{"property":"og:url","content":"http://www.codepit.tech/mynotes/mynotes/codenotes/graphql/introspection.html"}],["meta",{"property":"og:site_name","content":"Zuooの学习笔记"}],["meta",{"property":"og:title","content":"GraphQL 内省"}],["meta",{"property":"og:description","content":"与 REST 相比，赋予 GraphQL 众多优势的一个主要功能是“内省”。 GraphQL 查询语言是强类型的。 这种强类型系统提供了查询和理解潜在模式的能力。 模式充当前端和后端团队之间的契约。 但前端开发者如何了解后端模式是怎样的？ 他们如何防止过度抓取或不足抓取？ 这可能是由于“内省”查询。 内省查询 {#introspection-queri..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2023-05-22T06:53:00.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:tag","content":"GraphQL"}],["meta",{"property":"article:modified_time","content":"2023-05-22T06:53:00.000Z"}]]},"excerpt":"","headers":[{"level":2,"title":"内省查询","slug":"introspection-queries","link":"#introspection-queries","children":[]},{"level":2,"title":"社群工具","slug":"community-tooling","link":"#community-tooling","children":[]}],"git":{"createdTime":1684738380000,"updatedTime":1684738380000,"contributors":[{"name":"zql","email":"1241236275@qq.com","commits":1}]},"readingTime":{"minutes":1.34,"words":401},"filePathRelative":"codenotes/graphql/introspection.md","localizedDate":"2023年5月22日"}');export{t as data};
