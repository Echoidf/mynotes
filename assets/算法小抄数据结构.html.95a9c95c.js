import{_ as e}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as p,c as o,a as n,d as s,e as t,b as c,r as l}from"./app.193c9a2b.js";const r={},i=c(`<p>记录一下在学习王争的《数据结构与算法之美》专栏过程中的算法代码实现</p><hr><h2 id="java中常见数据结构-【备忘】" tabindex="-1"><a class="header-anchor" href="#java中常见数据结构-【备忘】" aria-hidden="true">#</a> Java中常见数据结构 【备忘】</h2><h3 id="一、list" tabindex="-1"><a class="header-anchor" href="#一、list" aria-hidden="true">#</a> 一、List</h3><ol><li><strong>ArrayList----数组</strong> 允许对元素进行快速随机访问,<strong>适合随机查找和遍历</strong>，不适合插入和删除</li><li><strong>Vector----数组实现，线程同步</strong> 某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此访问它比访问 ArrayList 慢</li><li><strong>LinkedList----双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环)</strong> 实现了List接口和Deque接口的双端链表,具有队列的特性,非线程安全。<strong>适合数据的动态插入和删除,随机访问和遍历速度比较慢</strong>,另外，还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用</li></ol><h3 id="二、set" tabindex="-1"><a class="header-anchor" href="#二、set" aria-hidden="true">#</a> 二、Set</h3><blockquote><p><strong><em>Set 注重独一无二的性质</em></strong> 对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号）判断的，如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方法</p></blockquote><ol><li><p><strong>HashSet----基于 HashMap 实现</strong> <br> 不保证元素顺序，但是元素唯一，添加重复元素时返回false 遍历方法：</p><ul><li>迭代器遍历</li><li>foreach遍历</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;使用Iterator遍历：&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> platformIterator <span class="token operator">=</span> platformSet<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>platformIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>platformIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;使用foreach遍历：&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> platform <span class="token operator">:</span> platformSet<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>platform<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>LinkedHashSet---- HashSet + LinkedHashMap</strong></p><p>是HashSet的子类，底层使用了LinkedHashMap，在HashSet的哈希表数据结构基础之上，增加了一个 <strong><em>双向链表</em></strong> 用来记录元素添加的顺序，能按照添加顺序遍历输出。需要频繁遍历的话效率可能高于HashSet，非线程安全</p></li><li><p><strong>TreeSet----红黑树</strong></p><p>主要功能用于排序（自然排序或者比较器排序）；不允许添加null值，会抛出空指针异常</p><p><strong>如何给自定义对象进行排序？</strong></p><p>3.1 自然排序</p><p>使自定义类实现接口Comparable，并重写该接口的方法compareTo，该方法会定义排序规则，返回值为整型</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Student</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果返回0，代表两个元素相同，只会保留第一个元素</p><p>如果返回值大于0，代表这个元素要排在参数中指定元素o的后面</p><p>如果返回值小于0，代表这个元素要排在参数中指定元素o的前面</p><p>3.2 比较器排序</p><p>新建一个比较器类，继承接口Comparator，重写接口中的Compare()方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">collection</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Comparator</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StudentComparator</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Student</span> o1<span class="token punctuation">,</span> <span class="token class-name">Student</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// 排序规则描述如下</span>
<span class="token comment">// 按照姓名的长度排序,长度短的排在前面,长度长的排在后面</span>
<span class="token comment">// 如果姓名的长度相同，按字典顺序比较String</span>
<span class="token comment">// 如果姓名完全相同,按年龄排序,年龄小的排在前面,年龄大的排在后面</span>

        <span class="token keyword">int</span> orderByNameLength <span class="token operator">=</span> o1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> o2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> orderByName <span class="token operator">=</span> orderByNameLength <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> o1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>o2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> orderByNameLength<span class="token punctuation">;</span>
        <span class="token keyword">int</span> orderByAge <span class="token operator">=</span> orderByName <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> o1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> o2<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> orderByName<span class="token punctuation">;</span>

        <span class="token keyword">return</span> orderByAge<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后修改下验证代码中声明studentTreeSet的代码即可：</p><p><code>TreeSet&lt;Student&gt; studentTreeSet = new TreeSet&lt;&gt;(new StudentComparator());</code></p></li></ol><h3 id="三、map" tabindex="-1"><a class="header-anchor" href="#三、map" aria-hidden="true">#</a> 三、Map</h3><ol><li><p><strong>HashMap----数组+链表+红黑树</strong> JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（<em>拉链法</em> 解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><blockquote><p>HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap 最多只允许一条记录的键为 null，允许多条记录的值为 null。HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。</p></blockquote><blockquote><p>在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)</p></blockquote></li><li><p><strong>ConcurrentHashMap----支持并发操作，线程安全</strong></p><ol><li>Segment段 整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁</li><li>线程安全（Segment 继承 ReentrantLock 加锁） ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全</li><li>并行度（默认 16） concurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。</li></ol></li><li><p><strong>TreeMap----红黑树（平衡二叉排序树）</strong> TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。 在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的 Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常</p></li><li><p><strong>HashTable----数组+链表</strong> Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，并且是 <strong><em>线程安全</em></strong> 的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap，因为 ConcurrentHashMap 引入了分段锁。<code>&lt;br/&gt;</code> Hashtable 不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换</p></li><li><p><strong>LinkedHashMap----记录插入顺序</strong> LinkedHashMap 是 HashMap 的一个子类，在其基础上，增加了一条双向链表，使得可以保持键值对的插入顺序，在用 Iterator 遍历 LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序</p></li></ol><h3 id="四、栈" tabindex="-1"><a class="header-anchor" href="#四、栈" aria-hidden="true">#</a> 四、栈</h3><h4 id="_1-0版本栈结构stack类" tabindex="-1"><a class="header-anchor" href="#_1-0版本栈结构stack类" aria-hidden="true">#</a> 1.0版本栈结构Stack类</h4><p>Stack 继承了 Vector 类，从 Vector 中继承了几个字段</p><ul><li>elementData :存储向量组件的数组缓冲区 – 我将其看作对象的引用</li><li>elementCount : 对象中的有效组件数</li><li>capacityIncrement : 向量的大小大于其容量时，容量自动增加的量。（与 Vector 一样，Stack 除了初始大小之外，可以自动进行扩容，扩容方式与 Vector 相同：正常情况下为原来大小的2倍)</li></ul><h4 id="_1-6版本栈结构deque接口" tabindex="-1"><a class="header-anchor" href="#_1-6版本栈结构deque接口" aria-hidden="true">#</a> 1.6版本栈结构Deque接口</h4><p>Deque 是一个线性的collection，支持在两端插入和移除元素。deque 是 “double ended queue（双端队列）” 的缩写。 大多数 Deque 实现对于它们能够包含的元素数没有固定限制，但此接口既支持有容量限制的双端队列，也支持没有固定大小限制的双端队列。</p><p>Deque 具有双端队列特性，有以下两种实现：</p><ul><li>作为 FIFO 的队列 —— LinkedList 类</li><li>作为 FILO 的栈 —— ArrayDeque 类</li></ul><table><thead><tr><th>集合类型</th><th>数据结构</th><th>初始化及扩容</th><th>查询时间复杂度</th><th>是否线程安全</th></tr></thead><tbody><tr><td>ArrayDeque</td><td>循环数组</td><td>初始化16  扩容2倍</td><td>O(1)</td><td>否</td></tr><tr><td>LinkedList</td><td>双向链表</td><td>无扩容机制</td><td>O(n)</td><td>否</td></tr></tbody></table><h4 id="arraydeque栈类" tabindex="-1"><a class="header-anchor" href="#arraydeque栈类" aria-hidden="true">#</a> ArrayDeque栈类</h4><p><strong>ArrayDeque 常用的方法如下所示。</strong></p><table><thead><tr><th>操作</th><th>方法</th></tr></thead><tbody><tr><td>入栈</td><td>push(E item)</td></tr><tr><td>出栈</td><td>poll() 栈为空时返回 null<br>pop() 栈为空时会抛出异常</td></tr><tr><td>查看栈顶</td><td>peek() 为空时返回 null</td></tr></tbody></table><h2 id="查看对应章节" tabindex="-1"><a class="header-anchor" href="#查看对应章节" aria-hidden="true">#</a> 查看对应章节</h2>`,23),u={href:"https://github.com/Echoidf/computer-course/tree/main/algorithm/src/main/java/%E9%93%BE%E8%A1%A8%E7%AF%87",target:"_blank",rel:"noopener noreferrer"},d={href:"https://github.com/Echoidf/computer-course/tree/main/algorithm/src/main/java/%E9%98%9F%E5%88%97%E7%AF%87",target:"_blank",rel:"noopener noreferrer"},k={href:"https://github.com/Echoidf/computer-course/tree/main/algorithm/src/main/java/%E5%A0%86%E6%A0%88%E7%AF%87",target:"_blank",rel:"noopener noreferrer"},m={href:"https://github.com/Echoidf/computer-course/tree/main/algorithm/src/main/java/%E9%80%92%E5%BD%92%E7%AF%87",target:"_blank",rel:"noopener noreferrer"},h={href:"https://github.com/Echoidf/computer-course/tree/main/algorithm/src/main/java/%E6%8E%92%E5%BA%8F%E7%AF%87",target:"_blank",rel:"noopener noreferrer"};function v(g,b){const a=l("ExternalLinkIcon");return p(),o("div",null,[i,n("ul",null,[n("li",null,[n("a",u,[s("链表篇"),t(a)])]),n("li",null,[n("a",d,[s("队列篇"),t(a)])]),n("li",null,[n("a",k,[s("堆栈篇"),t(a)])]),n("li",null,[n("a",m,[s("递归篇"),t(a)])]),n("li",null,[n("a",h,[s("排序篇"),t(a)])])])])}const S=e(r,[["render",v],["__file","算法小抄数据结构.html.vue"]]);export{S as default};
