import{_ as l}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as i,c as r,a as s,b as a,d as e,e as t,r as o}from"./app.78c2d4e1.js";const p={},c=s("h2",{id:"一、clickhouse入门",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#一、clickhouse入门","aria-hidden":"true"},"#"),a(" 一、ClickHouse入门")],-1),d=s("h3",{id:"_1-参考文档",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#_1-参考文档","aria-hidden":"true"},"#"),a(" 1.参考文档")],-1),u={href:"https://clickhouse.com/docs/zh/",target:"_blank",rel:"noopener noreferrer"},k={href:"https://clickhouse.com/docs/en/home/",target:"_blank",rel:"noopener noreferrer"},h=s("p",null,"注：学习时可以参考中文文档，但是具体内容不如英文版全面",-1),v=s("p",null,"还有一些学习教程",-1),m={href:"https://cloud.fynote.com/share/d/7551#1-1-ClickHouse%E4%B8%8E%E5%85%B6%E7%89%B9%E6%80%A7_0",target:"_blank",rel:"noopener noreferrer"},b={href:"https://www.saoniuhuo.com/article/detail-36706.html",target:"_blank",rel:"noopener noreferrer"},g={href:"https://www.bilibili.com/video/BV1Yh411z7os/?spm_id_from=333.337.search-card.all.click&vd_source=bdbfe17d291002594c9e265913af7f71",target:"_blank",rel:"noopener noreferrer"},f=t('<h3 id="_2-简介" tabindex="-1"><a class="header-anchor" href="#_2-简介" aria-hidden="true">#</a> 2.简介</h3><p>ClickHouse 是俄罗斯的 Yandex 于 2016 年开源的<strong>列式存储数据库</strong>（DBMS），使用 C++语言编写，主要用于<strong>在线分析查询</strong>（OLAP），能够使用 SQL 查询实时生成分析数据报告。</p><p>ClickHouse核心特性：</p><p><img src="https://s2.loli.net/2022/12/25/Qs7IrJE1UqMoj8Z.jpg" alt="ch核心特性"></p><h4 id="_2-1列式存储" tabindex="-1"><a class="header-anchor" href="#_2-1列式存储" aria-hidden="true">#</a> 2.1列式存储</h4><ul><li>对于列的聚合，计数，求和等统计操作原因优于行式存储</li><li>由于某一列的数据类型都是相同的，针对于数据存储更容易进行数据压缩，每一列选择更优的数据压缩算法，大大提高了数据的压缩比重</li><li>由于数据压缩比更好，一方面节省了磁盘空间，另一方面对于 cache 也有了更大的发挥空间</li></ul><h4 id="_2-2dbms的功能" tabindex="-1"><a class="header-anchor" href="#_2-2dbms的功能" aria-hidden="true">#</a> 2.2DBMS的功能</h4><p>几乎覆盖了标准 SQL 的大部分语法，包括 DDL 和 DML，以及配套的各种函数，用户管理及权限管理，数据的备份与恢复</p><h4 id="_2-3多样化的引擎" tabindex="-1"><a class="header-anchor" href="#_2-3多样化的引擎" aria-hidden="true">#</a> 2.3多样化的引擎</h4><p>ClickHouse 和 MySQL 类似，把表级的存储引擎插件化，根据表的不同需求可以设定不同的存储引擎。目前包括合并树、日志、接口和其他四大类 20 多种引擎。</p><h4 id="_2-4高吞吐写入能力" tabindex="-1"><a class="header-anchor" href="#_2-4高吞吐写入能力" aria-hidden="true">#</a> 2.4高吞吐写入能力</h4><p>ClickHouse 采用类 LSM Tree的结构，数据写入后定期在后台 Compaction。通过类 LSM tree的结构，ClickHouse 在数据导入时全部是顺序 append 写，写入后数据段不可更改，在后台compaction 时也是多个段 merge sort 后顺序写回磁盘。顺序写的特性，充分利用了磁盘的吞吐能力，即便在 HDD 上也有着优异的写入性能。官方公开 benchmark 测试显示能够达到 50MB-200MB/s 的写入吞吐能力，按照每行100Byte 估算，大约相当于 50W-200W 条/s 的写入速度</p><h4 id="_2-5数据分区与线程级并行" tabindex="-1"><a class="header-anchor" href="#_2-5数据分区与线程级并行" aria-hidden="true">#</a> 2.5数据分区与线程级并行</h4><p>ClickHouse 将数据划分为多个 partition，每个 partition 再进一步划分为多个 index granularity(索引粒度)，然后通过多个 CPU核心分别处理其中的一部分来实现并行数据处理。在这种设计下，单条 Query 就能利用整机所有 CPU。极致的并行处理能力，极大的降低了查询延时。所以，ClickHouse 即使对于大量数据的查询也能够化整为零平行处理。但是有一个弊端就是对于单条查询使用多 cpu，就不利于同时并发多条查询。所以对于高 qps 的查询业务，ClickHouse 并不是强项</p><h3 id="_3-clickhouse常用命令" tabindex="-1"><a class="header-anchor" href="#_3-clickhouse常用命令" aria-hidden="true">#</a> 3.Clickhouse常用命令</h3><p>参考：</p>',16),_={href:"https://developer.aliyun.com/article/713387#:~:text=ClickHouse%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4",target:"_blank",rel:"noopener noreferrer"},x={href:"https://blog.csdn.net/anyitian/article/details/115717758",target:"_blank",rel:"noopener noreferrer"},E=t(`<p>客户端常用参数</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>--host, <span class="token parameter variable">-h</span> -– 服务端的 <span class="token function">host</span> 名称, 默认是 <span class="token string">&#39;localhost&#39;</span>。 您可以选择使⽤ <span class="token function">host</span> 名称或者 IPv4 或 IPv6 地址
<span class="token parameter variable">--port</span> – 连接的端⼝，默认值： <span class="token number">9000</span>。注意 HTTP 接⼝以及 TCP 原⽣接⼝是使⽤不同端⼝的 
--user, <span class="token parameter variable">-u</span> – ⽤户名。 默认值： default。 
<span class="token parameter variable">--password</span> – 密码。 默认值： 空字符串。 
--query, <span class="token parameter variable">-q</span> – ⾮交互模式下的查询语句. 
--database, <span class="token parameter variable">-d</span> – 默认当前操作的数据库. 默认值： 服务端默认的配置 （默认是 default ） 
--multiline, <span class="token parameter variable">-m</span> – 如果指定，允许多⾏语句查询（Enter 仅代表换⾏，不代表查询语句完结） 
--multiquery, <span class="token parameter variable">-n</span> – 如果指定, 允许处理⽤逗号分隔的多个查询，只在⾮交互模式下⽣效
--format, <span class="token parameter variable">-f</span> – 使⽤指定的默认格式输出结果。 
--vertical, <span class="token parameter variable">-E</span> – 如果指定，默认情况下使⽤垂直格式输出结果。这与 <span class="token string">&#39;--format=Vertical&#39;</span> 相同。在这种格式中，每个值都在单独的⾏上打印，这种⽅式对显示宽表很有帮助。
--time, <span class="token parameter variable">-t</span> – 如果指定，⾮交互模式下会打印查询执⾏的时间到 <span class="token string">&#39;stderr&#39;</span> 中。
<span class="token parameter variable">--stacktrace</span> – 如果指定，如果出现异常，会打印堆栈跟踪信息。
-config-file – 配置⽂件的名称

<span class="token comment">## 客户端登录</span>
\`\`\`bash
clickhouse-client <span class="token parameter variable">--user</span> xxxx  <span class="token parameter variable">--password</span> xxxx
clickhouse-client <span class="token parameter variable">-u</span> xxxx  <span class="token parameter variable">--password</span> xxxx

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>导入导出</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>clickhouse-client <span class="token parameter variable">--query</span><span class="token operator">=</span><span class="token string">&quot;INSERT INTO database.table_name FORMAT CSVWithNames&quot;</span> <span class="token operator">&lt;</span> /path/import_filename.csv

clickhouse-client <span class="token parameter variable">--query</span><span class="token operator">=</span><span class="token string">&quot;SELECT * FROM database.table_name FORMAT CSV&quot;</span> <span class="token function">sed</span> <span class="token string">&#39;s/&quot;//g&#39;</span> <span class="token operator">&gt;</span> /path/export_filename.csv
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-表引擎" tabindex="-1"><a class="header-anchor" href="#_4-表引擎" aria-hidden="true">#</a> 4.表引擎</h3><p>表引擎（即表的类型）决定了：</p><ul><li>数据的存储方式和位置，写到哪里以及从哪里读取数据</li><li>支持哪些查询以及如何支持。</li><li>并发数据访问。</li><li>索引的使用（如果存在）。</li><li>是否可以执行多线程请求。</li><li>数据复制参数。</li></ul><h4 id="_1-tinylog" tabindex="-1"><a class="header-anchor" href="#_1-tinylog" aria-hidden="true">#</a> （1）TinyLog</h4><p>最简单的表引擎，用于将数据存储在磁盘上。每列都存储在单独的压缩文件中，写入时，数据将附加到文件末尾。 该引擎没有并发控制</p><ul><li>如果同时从表中读取和写入数据，则读取操作将抛出异常；</li><li>如果同时写入多个查询中的表，则数据将被破坏。</li></ul><p>这种表引擎的典型用法是 write-once：首先只写入一次数据，然后根据需要多次读取。此引擎<strong>适用于相对较小的表</strong>（建议最多 1,000,000 行）。<strong>如果有许多小表，则使用此表引擎是适合的，因为它比需要打开的文件更少</strong>。当拥有大量小表时，可能会导致性能低下。 <strong>不支持索引</strong>。 案例：创建一个 TinyLog 引擎的表并插入一条数据</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">:</span><span class="token punctuation">)</span>create table t <span class="token punctuation">(</span>a UInt16, b String<span class="token punctuation">)</span> <span class="token assign-left variable">ENGINE</span><span class="token operator">=</span>TinyLog<span class="token punctuation">;</span>
<span class="token builtin class-name">:</span><span class="token punctuation">)</span>insert into t <span class="token punctuation">(</span>a, b<span class="token punctuation">)</span> values <span class="token punctuation">(</span><span class="token number">1</span>, <span class="token string">&#39;abc&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-memory" tabindex="-1"><a class="header-anchor" href="#_2-memory" aria-hidden="true">#</a> （2） Memory</h4><p>内存引擎，数据以未压缩的原始形式直接保存在内存当中，服务器重启数据就会消失。读写操作不会相互阻塞，不支持索引。简单查询下有非常非常高的性能表现（超过 10G/s）。 一般用到它的地方不多，除了用来测试，就是在需要非常高的性能，同时数据量又不太大（上限大概 1 亿行）的场景。</p><h4 id="_3-merge" tabindex="-1"><a class="header-anchor" href="#_3-merge" aria-hidden="true">#</a> （3） Merge</h4><p>Merge 引擎 (不要跟 MergeTree 引擎混淆) 本身不存储数据，但可用于同时从任意多个其他的表中读取数据。 读是自动并行的，不支持写入。读取时，那些被真正读取到数据的表的索引（如果有的话）会被使用。 Merge 引擎的参数：一个数据库名和一个用于匹配表名的正则表达式。 案例：先建 t1，t2，t3 三个表，然后用 Merge 引擎的 t 表再把它们链接起来。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">:</span><span class="token punctuation">)</span>create table t1 <span class="token punctuation">(</span>id UInt16, name String<span class="token punctuation">)</span> <span class="token assign-left variable">ENGINE</span><span class="token operator">=</span>TinyLog<span class="token punctuation">;</span>
<span class="token builtin class-name">:</span><span class="token punctuation">)</span>create table t2 <span class="token punctuation">(</span>id UInt16, name String<span class="token punctuation">)</span> <span class="token assign-left variable">ENGINE</span><span class="token operator">=</span>TinyLog<span class="token punctuation">;</span>
<span class="token builtin class-name">:</span><span class="token punctuation">)</span>create table t3 <span class="token punctuation">(</span>id UInt16, name String<span class="token punctuation">)</span> <span class="token assign-left variable">ENGINE</span><span class="token operator">=</span>TinyLog<span class="token punctuation">;</span>

<span class="token builtin class-name">:</span><span class="token punctuation">)</span>insert into t1<span class="token punctuation">(</span>id, name<span class="token punctuation">)</span> values <span class="token punctuation">(</span><span class="token number">1</span>, <span class="token string">&#39;first&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin class-name">:</span><span class="token punctuation">)</span>insert into t2<span class="token punctuation">(</span>id, name<span class="token punctuation">)</span> values <span class="token punctuation">(</span><span class="token number">2</span>, <span class="token string">&#39;second&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin class-name">:</span><span class="token punctuation">)</span>insert into t3<span class="token punctuation">(</span>id, name<span class="token punctuation">)</span> values <span class="token punctuation">(</span><span class="token number">3</span>, <span class="token string">&#39;i am in t3&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token builtin class-name">:</span><span class="token punctuation">)</span>create table t <span class="token punctuation">(</span>id UInt16, name String<span class="token punctuation">)</span> <span class="token assign-left variable">ENGINE</span><span class="token operator">=</span>Merge<span class="token punctuation">(</span>currentDatabase<span class="token punctuation">(</span><span class="token punctuation">)</span>, <span class="token string">&#39;^t&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token builtin class-name">:</span><span class="token punctuation">)</span> <span class="token keyword">select</span> * from t<span class="token punctuation">;</span>
┌─id─┬─name─┐
│  <span class="token number">2</span> │ second │
└────┴──────┘
┌─id─┬─name──┐
│  <span class="token number">1</span> │ first │
└────┴───────┘
┌─id─┬─name───────┐
│ <span class="token number">3</span>     │ i am <span class="token keyword">in</span> t3 │
└────┴────────────┘
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_4-mergetree" tabindex="-1"><a class="header-anchor" href="#_4-mergetree" aria-hidden="true">#</a> （4）MergeTree</h4><p>Clickhouse 中最强大的表引擎当属 MergeTree （合并树）引擎及该系列（MergeTree）中的其他引擎。 MergeTree 引擎系列的基本理念如下。当你有巨量数据要插入到表中，你要<strong>高效地一批批写入数据片段</strong>，并希望这些数据片段<strong>在后台按照一定规则合并</strong>。相比在插入时不断修改（重写）数据进存储，这种策略会高效很多。 格式：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
(
    name1 [type1] [DEFAULT|MATERIALIZED|ALIAS expr1],
    name2 [type2] [DEFAULT|MATERIALIZED|ALIAS expr2],
    ...
) ENGINE = VersionedCollapsingMergeTree(sign, version)
[PARTITION BY expr]
[ORDER BY expr]
[PRIMARY KEY expr]
[SAMPLE BY expr]
[SETTINGS name=value, ...]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>PARTITION BY [选填]：分区键，用于指定表数据以何种标准进行分区。</p><p>ORDER BY[选填]：排序键</p><p>PRIMARY KEY [选填] ： 主键</p><p>SAMPLE BY [选填]：抽样表达式，用于声明数据以何种标 准进行采样</p><p>SETTINGS：index_granularity [选填]：它表示索引的粒度，默认值为 8192。也就是说，MergeTree的索引在默认情况下，每间隔8192行数据 才生成一条索引，稀疏索引</p><p>MergeTree 其实还有很多参数(绝大多数用默认值即可)，但是有三个参数比较重要：</p><ol><li><p><strong>partition by 分区(可选)</strong></p><p>分区的目的主要是降低扫描的范围，优化查询速度，不填只有一个分区。MergeTree 是以列文件+索引文件+表定义文件组成的，但是如果设定了分区那么这些文件就会保存到不同的分区目录中。</p><p>分区后，面对涉及跨分区的查询统计，ClickHouse 会以分区为单位并行处理。</p><hr><p>任何一个批次的数据写入都会产生一个临时分区，不会纳入任何一个已有的分区。写入后的某个时刻（大概 10-15 分钟后），ClickHouse 会自动执行合并操作（等不及也可以手动通过 optimize 执行），把临时分区的数据，合并到已有分区中。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>optimize table xxxx final<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr></li><li><p><strong>primary key 主键(可选)</strong></p><p>ClickHouse 中的主键，和其他数据库不太一样，<strong>它只提供了数据的一级索引</strong>，但是却不是唯一约束。这就意味着是可以存在相同 primary key 的数据的。</p><p>待主键定义之后， MergeTree会依据index_granularity间隔（默认8192行），为数据表生成 一级索引并保存至primary.idx文件内，索引数据按照PRIMARY KEY排 序。相比使用PRIMARY KEY定义，更为常见的简化形式是通过 ORDER BY指代主键。</p><p>每间隔8192行数据就会取一次主键的值作为索引值，索引数据最终会被写入primary.idx文件进行保存</p><p>主键的设定主要依据是查询语句中的 where 条件。</p><p>根据条件通过对主键进行某种形式的二分查找，能够定位到对应的 index granularity,避免了全表扫描。</p><blockquote><p>【index granularity索引粒度，ClickHouse 中的 MergeTree 默认是 8192,指在稀疏索引中两个相邻索引对应数</p><p>据的间隔,官方不建议修改这个值，除非该列存在大量重复值，比如在一个分区中几万行才有一个不同数据。】</p></blockquote></li><li><p><strong>order by （必选）</strong></p><p>order by 设定了分区内的数据按照哪些字段顺序进行有序保存。</p><p>order by 是 MergeTree 中唯一一个必填项，甚至比 primary key 还重要，因为当用户不设置主键的情况，很多处理会依照 order by 的字段进行处理（比如去重和汇总）。</p><p>要求：主键必须是 order by 字段的前缀字段。</p><p>比如 order by 字段是 (id,sku_id) 那么主键必须是 id 或者(id,sku_id)</p></li></ol><h4 id="_5-replacingmergetree" tabindex="-1"><a class="header-anchor" href="#_5-replacingmergetree" aria-hidden="true">#</a> （5）ReplacingMergeTree</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>CREATE TABLE replace_table<span class="token punctuation">(</span>
<span class="token function">id</span> String,  
code String,   
create_time DateTime
<span class="token punctuation">)</span>ENGINE <span class="token operator">=</span> ReplacingMergeTree<span class="token punctuation">(</span><span class="token punctuation">)</span> 
PARTITION BY toYYYYMM<span class="token punctuation">(</span>create_time<span class="token punctuation">)</span> 
ORDER BY <span class="token punctuation">(</span>id,code<span class="token punctuation">)</span> //根据id与code去重 
PRIMARY KEY <span class="token function">id</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>只有在相同的数据分区内重复的数据才可以被删除，而不同数 据分区之间的重复数据依然不能被剔除</p><ul><li><strong>使用ORBER BY排序键作为判断重复数据的唯一键</strong></li><li>只有在合并分区的时候才会触发删除重复数据的逻辑。</li><li>以数据分区为单位删除重复数据。当分区合并时，同一分区 内的重复数据会被删除；不同分区之间的重复数据不会被删除。</li><li>在进行数据去重时，因为分区内的数据已经基于ORBER BY 进行了排序，所以能够找到那些相邻的重复数据。</li><li>数据去重策略有两种：</li><li>如果没有设置ver版本号，则保留同一组重复数据中的最后一 行。</li><li>如果设置了ver版本号，则保留同一组重复数据中ver字段取值最 大的那一行。</li></ul><h4 id="_6-summingmergetree" tabindex="-1"><a class="header-anchor" href="#_6-summingmergetree" aria-hidden="true">#</a> （6）SummingMergeTree</h4><p>该引擎继承自 MergeTree。能够在合并分区的时候按照预先定义的条件聚合汇总数据，将同一分组下的多行数据汇总合并成一行，这样既减少了数据行，又降低了后续汇总查询的开销。<strong>适用于不查询明细，只关心以维度进行汇总聚合结果的场景</strong>。</p><h3 id="_5-二级索引" tabindex="-1"><a class="header-anchor" href="#_5-二级索引" aria-hidden="true">#</a> 5.二级索引</h3><p>granularity与index_granularity的关系</p><p>index_granularity定 义了数据的粒度，而granularity定义了聚合信息汇总的粒度。换言之， granularity定义了一行跳数索引能够跳过多少个index_granularity区间的数据。</p><p>二级索引类型</p><ul><li>minmax：minmax索引记录了一段数据内的最小和最大极值，其索引的作用类似分区目录的minmax索引，能够快速跳过无用的数据区间。</li><li>set：set索引直接记录了声明字段或表达式的取值</li><li>ngrambf<em>v1：ngrambf</em>v1索引记录的是数据短语的布隆表过滤器，只支持String和FixedString数据类型</li><li>tokenbf<em>v1：tokenbf</em>v1索引是ngrambf_v1的变种，同样也是 一种布隆过滤器索引</li></ul><h3 id="_6-数据库引擎之mysql" tabindex="-1"><a class="header-anchor" href="#_6-数据库引擎之mysql" aria-hidden="true">#</a> 6.数据库引擎之Mysql</h3><p>服务器安装mysql</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>apt-get install mysql-server
//启动服务
service mysql start
//进入服务
mysql -uroot -p
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>MySQL表引擎可以与MySQL数据库中的数据表建立映射，并通过 SQL向其发起远程查询，包括SELECT和INSERT，它的声明方式如 下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ENGINE = MySQL(&#39;host:port&#39;, &#39;database&#39;, &#39;table&#39;, &#39;user&#39;, &#39;password&#39;[,replace_query, &#39;on_duplicate_clause&#39;])
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>replacequery默认为0，对应MySQL的REPLACE INTO语法。如果将它设置为1，则会用REPLACE INTO代替INSERT INTO。</p><p>on<em>duplicate</em>clause默认为0，对应MySQL的ON DUPLICATE KEY 语法。如果需要使用该设置，则必须replacequery设置成0</p></blockquote><p><strong>clickhouse创建映射表</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>CREATE TABLE test(
id UInt32,
name String
)ENGINE = MySQL(&#39;127.0.0.1:3306&#39;, &#39;test&#39;,
&#39;test&#39;, &#39;root&#39;, &#39;&#39;)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>插入数据</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">TABLE</span> test <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">&#39;流程1&#39;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查询Mysql 表 test ，发现数据已经被远程写入了。</p><h2 id="二、分布式安装" tabindex="-1"><a class="header-anchor" href="#二、分布式安装" aria-hidden="true">#</a> 二、分布式安装</h2><h3 id="_1-搭建zooker集群" tabindex="-1"><a class="header-anchor" href="#_1-搭建zooker集群" aria-hidden="true">#</a> 1.搭建Zooker集群</h3>`,51),y={href:"https://echoidf.github.io/posts/virtualbox%E6%90%AD%E5%BB%BAzookeeper%E9%9B%86%E7%BE%A4/",target:"_blank",rel:"noopener noreferrer"},T=t(`<p>可以先进行单机版的安装，然后再直接复制虚拟机，进行简单配置即可</p><h3 id="_2-安装clickhouse" tabindex="-1"><a class="header-anchor" href="#_2-安装clickhouse" aria-hidden="true">#</a> 2.安装ClickHouse</h3><p>先安装一下依赖：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> yum <span class="token function">install</span> <span class="token parameter variable">-y</span> libtool
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>将四个依赖包上传到虚拟机指定的目录，并安装依赖</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">tar</span> <span class="token parameter variable">-xzvf</span> clickhouse-common-static-<span class="token variable">$LATEST_VERSION</span>.tgz
<span class="token function">sudo</span> clickhouse-common-static-<span class="token variable">$LATEST_VERSION</span>/install/doinst.sh

<span class="token function">tar</span> <span class="token parameter variable">-xzvf</span> clickhouse-common-static-dbg-<span class="token variable">$LATEST_VERSION</span>.tgz
<span class="token function">sudo</span> clickhouse-common-static-dbg-<span class="token variable">$LATEST_VERSION</span>/install/doinst.sh

<span class="token function">tar</span> <span class="token parameter variable">-xzvf</span> clickhouse-server-<span class="token variable">$LATEST_VERSION</span>.tgz
<span class="token function">sudo</span> clickhouse-server-<span class="token variable">$LATEST_VERSION</span>/install/doinst.sh

<span class="token function">tar</span> <span class="token parameter variable">-xzvf</span> clickhouse-client-<span class="token variable">$LATEST_VERSION</span>.tgz
<span class="token function">sudo</span> clickhouse-client-<span class="token variable">$LATEST_VERSION</span>/install/doinst.sh
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注：安装第3个包clickhouse-server时，clickhouse会在数据库中创建一个默认的用户default，安装过程中，会需要给这个default用户输入一个密码。这里进行测试，就直接回车，不设置密码即可。</p><p>安装完成后，就可以使用clickhouse start指令启动clickhouse服务了</p><p>如果遇到启动错误，可以查询启动日志，查看错误信息：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> journalctl <span class="token parameter variable">-xe</span>
 <span class="token function">cat</span> /var/log/clickhouse-server/clickhouse-server.log
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-目录解析" tabindex="-1"><a class="header-anchor" href="#_3-目录解析" aria-hidden="true">#</a> 3.目录解析</h3><table><thead><tr><th style="text-align:left;">目录</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left;">/var/lib/clickhouse/</td><td>数据文件</td></tr><tr><td style="text-align:left;">/var/log/clickhouse-server/</td><td>日志文件</td></tr><tr><td style="text-align:left;">/etc/clickhouse-server/</td><td>配置文件（config.xml和users.xml等）</td></tr><tr><td style="text-align:left;">/usr/bin/</td><td>执行脚本（clickhouse和clickhouse-client等）</td></tr><tr><td style="text-align:left;">clickhouse在安装时，会默认创建一个clickhouse用户来部署这些文件</td><td></td></tr></tbody></table><h3 id="_4-常见命令" tabindex="-1"><a class="header-anchor" href="#_4-常见命令" aria-hidden="true">#</a> 4.常见命令</h3><table><thead><tr><th style="text-align:left;">功能</th><th>命令</th></tr></thead><tbody><tr><td style="text-align:left;">启动Server</td><td>systemctl start clickhouse-server</td></tr><tr><td style="text-align:left;">关闭Server</td><td>systemctl stop clickhouse-server</td></tr><tr><td style="text-align:left;">重启Server</td><td>systemctl restart clickhouse-server</td></tr><tr><td style="text-align:left;">查看状态</td><td>systemctl status clickhouse-server</td></tr><tr><td style="text-align:left;">客户端连接</td><td>clickhouse-client [--password (your password)]</td></tr></tbody></table><h3 id="_5-修改配置文件" tabindex="-1"><a class="header-anchor" href="#_5-修改配置文件" aria-hidden="true">#</a> 5.修改配置文件</h3>`,15),M={href:"https://echoidf.github.io/posts/virtualbox%E6%90%AD%E5%BB%BAzookeeper%E9%9B%86%E7%BE%A4/",target:"_blank",rel:"noopener noreferrer"},I=t(`<p>修改3台服务器ClickHouse配置文件 /etc/clickhouse-server/config.xml</p><ol><li><p>在 &lt;remote_servers&gt; 标签内添加如下配置: 配置副本节点</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&lt;</span>nt_1shards_3replicas<span class="token operator">&gt;</span> 
  <span class="token operator">&lt;</span>shard<span class="token operator">&gt;</span> 
    <span class="token operator">&lt;</span>internal_replication<span class="token operator">&gt;</span>true<span class="token operator">&lt;</span>/internal_replication<span class="token operator">&gt;</span>  
    <span class="token operator">&lt;</span>replica<span class="token operator">&gt;</span> 
      <span class="token operator">&lt;</span>host<span class="token operator">&gt;</span>node0<span class="token operator"><span class="token file-descriptor important">1</span>&lt;</span>/host<span class="token operator">&gt;</span>  
      <span class="token operator">&lt;</span>port<span class="token operator">&gt;</span><span class="token number">900</span><span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span>/port<span class="token operator">&gt;</span> 
    <span class="token operator">&lt;</span>/replica<span class="token operator">&gt;</span>  
    <span class="token operator">&lt;</span>replica<span class="token operator">&gt;</span> 
      <span class="token operator">&lt;</span>host<span class="token operator">&gt;</span>node0<span class="token operator"><span class="token file-descriptor important">2</span>&lt;</span>/host<span class="token operator">&gt;</span>  
      <span class="token operator">&lt;</span>port<span class="token operator">&gt;</span><span class="token number">900</span><span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span>/port<span class="token operator">&gt;</span> 
    <span class="token operator">&lt;</span>/replica<span class="token operator">&gt;</span>  
    <span class="token operator">&lt;</span>replica<span class="token operator">&gt;</span> 
      <span class="token operator">&lt;</span>host<span class="token operator">&gt;</span>node0<span class="token operator"><span class="token file-descriptor important">3</span>&lt;</span>/host<span class="token operator">&gt;</span>  
      <span class="token operator">&lt;</span>port<span class="token operator">&gt;</span><span class="token number">900</span><span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span>/port<span class="token operator">&gt;</span> 
    <span class="token operator">&lt;</span>/replica<span class="token operator">&gt;</span> 
  <span class="token operator">&lt;</span>/shard<span class="token operator">&gt;</span> 
<span class="token operator">&lt;</span>/nt_1shards_3replicas<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>添加zookeeper配置</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&lt;</span>zookeeper<span class="token operator">&gt;</span> 
  <span class="token operator">&lt;</span>node <span class="token assign-left variable">index</span><span class="token operator">=</span><span class="token string">&quot;1&quot;</span><span class="token operator">&gt;</span> 
    <span class="token operator">&lt;</span>host<span class="token operator">&gt;</span>node0<span class="token operator"><span class="token file-descriptor important">1</span>&lt;</span>/host<span class="token operator">&gt;</span>  
    <span class="token operator">&lt;</span>port<span class="token operator">&gt;</span><span class="token number">218</span><span class="token operator"><span class="token file-descriptor important">1</span>&lt;</span>/port<span class="token operator">&gt;</span> 
  <span class="token operator">&lt;</span>/node<span class="token operator">&gt;</span>  
  <span class="token operator">&lt;</span>node <span class="token assign-left variable">index</span><span class="token operator">=</span><span class="token string">&quot;2&quot;</span><span class="token operator">&gt;</span> 
    <span class="token operator">&lt;</span>host<span class="token operator">&gt;</span>node0<span class="token operator"><span class="token file-descriptor important">2</span>&lt;</span>/host<span class="token operator">&gt;</span>  
    <span class="token operator">&lt;</span>port<span class="token operator">&gt;</span><span class="token number">218</span><span class="token operator"><span class="token file-descriptor important">1</span>&lt;</span>/port<span class="token operator">&gt;</span> 
  <span class="token operator">&lt;</span>/node<span class="token operator">&gt;</span>  
  <span class="token operator">&lt;</span>node <span class="token assign-left variable">index</span><span class="token operator">=</span><span class="token string">&quot;3&quot;</span><span class="token operator">&gt;</span> 
    <span class="token operator">&lt;</span>host<span class="token operator">&gt;</span>node0<span class="token operator"><span class="token file-descriptor important">3</span>&lt;</span>/host<span class="token operator">&gt;</span>  
    <span class="token operator">&lt;</span>port<span class="token operator">&gt;</span><span class="token number">218</span><span class="token operator"><span class="token file-descriptor important">1</span>&lt;</span>/port<span class="token operator">&gt;</span> 
  <span class="token operator">&lt;</span>/node<span class="token operator">&gt;</span> 
<span class="token operator">&lt;</span>/zookeeper<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>添加macros配置</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&lt;</span>macros<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>shard<span class="token operator">&gt;</span><span class="token operator"><span class="token file-descriptor important">1</span>&lt;</span>/shard<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>replica<span class="token operator">&gt;</span><span class="token number">192.168</span>.56.15<span class="token operator"><span class="token file-descriptor important">4</span>&lt;</span>/replica<span class="token operator">&gt;</span> <span class="token comment">#这里每个结点的配置添加当前节点IP</span>
<span class="token operator">&lt;</span>/macros<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>重启使配置生效</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>systemctl restart clickhouse-server.service
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>ClickHouse-Client查看配置是否生效：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token keyword">select</span> * from system.clusters<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><p><img src="https://s2.loli.net/2022/12/25/87F3xQZMECsTKwt.png" alt=""></p><p>可以看出集群名是：nt_1shards_3replicas</p><h2 id="三、物化视图" tabindex="-1"><a class="header-anchor" href="#三、物化视图" aria-hidden="true">#</a> 三、物化视图</h2><h3 id="_1-什么是视图" tabindex="-1"><a class="header-anchor" href="#_1-什么是视图" aria-hidden="true">#</a> 1.什么是视图？</h3><p>在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。</p><p>视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。我们可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，我们也可以提交数据，就像这些来自于某个单一的表。</p><p>**注释：**数据库的设计和结构不会受到视图中的函数、where 或 join 语句的影响。</p><h3 id="_2-clickhouse物化视图" tabindex="-1"><a class="header-anchor" href="#_2-clickhouse物化视图" aria-hidden="true">#</a> 2.ClickHouse物化视图</h3><p>物化视图（Materialized Views，以下简称 MV）是一种特殊的视图，它的数据会持久化。那么在查询 MV 时，并不会去访问基表，而是直接从 MV 里读数据。</p><p>当然，基表的数据会修改，那么 MV 的数据也要跟着修改。</p><h4 id="典型使用场景" tabindex="-1"><a class="header-anchor" href="#典型使用场景" aria-hidden="true">#</a> 典型使用场景</h4><p><strong>1.加速查询</strong></p><p>有些查询需要访问大量的数据，而且每天要查询数次，那么就可以利用 MV。这样不仅查询更快，还降低了系统的 CPU 和 IO 开销。</p><p>同时，还可以在 MV 上建索引、分区以进一步提高性能。</p><p><strong>2.数据仓库</strong></p><p>把多个数据源的数据收集并存储的数据库，就叫数据仓库（Data Warehousing）。</p><p>MV 的作用是把多个数据源的数据收集起来，而不是直接复制数据。这样在数据仓库查询时，只用访问 MV ，而不用访问远程的数据源。</p><p><strong>3.数据集成</strong></p><p>数据集成（Data Integration）是把多个数据源的相同对象进行匹配（类似于 outer join），组合为更大的对象。</p><p>因为匹配条件很难计算，而 MV 可以保存组合后的对象，所以复用的代价就很低了。</p><p><strong>4.数据备份</strong></p><p>一些场景下（例如 field sales），副本在固定时刻会断开网络，要在重新连接网络时同步数据，那么需要在需要时更新副本或者定期更新。</p><p>这种需要恰巧符合 MV 的能力，所以有一种备份叫 MV 备份。这些场景的 MV 包含了基表的全部或部分数据。</p><p><strong>5.当成快照使用</strong></p><p>MV 不一定要实时更新，那么每次 MV 更新完，就相当于是基表的一个快照。可以利用这个特定，来实现特定的业务逻辑。</p><p>举个例子，有个显示文章的系统，用户可以通过前端查看文章。后台可以随时修改文章并保存，但是希望前端不要马上看到，而是修改完以后一次刷新到前端显示。</p><p>这样我们就可以用 MV 来实现：后台修改的是基表，前端读的是 MV。后台修改完后，再手动刷新 MV，让前端看到。</p><h4 id="clickhouse中的物化视图" tabindex="-1"><a class="header-anchor" href="#clickhouse中的物化视图" aria-hidden="true">#</a> Clickhouse中的物化视图</h4>`,30),S={href:"https://cloud.tencent.com/developer/article/1988528",target:"_blank",rel:"noopener noreferrer"},A=t(`<div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token punctuation">[</span>MATERIALIZED<span class="token punctuation">]</span> <span class="token keyword">VIEW</span> <span class="token punctuation">[</span><span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>db<span class="token punctuation">.</span><span class="token punctuation">]</span>table_name <span class="token punctuation">[</span><span class="token keyword">TO</span><span class="token punctuation">[</span>db<span class="token punctuation">.</span><span class="token punctuation">]</span>name<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">engine</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>POPULATE<span class="token punctuation">]</span> <span class="token keyword">AS</span> <span class="token keyword">SELECT</span> …
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>也是create语法，会创建一个隐藏的目标表来保存视图数据。也可以TO 表名，保存到一张显式的表。没有加TO表名，表名默认就是 .inner.物化视图名。</p><p><strong>物化视图中需要注意的几点</strong>:</p><ol><li>必须指定物化视图的engine 用于数据存储</li><li>TO [db].[table]语法的时候，不得使用POPULATE。</li><li>查询语句(select）可以包含下面的子句：DISTINCT, GROUP BY, ORDER BY, LIMIT…</li><li>物化视图的alter操作有些限制，操作起来不大方便。</li><li>物化视图是种特殊的数据表，可以用show tables 查看</li></ol><p>创建物化视图时一般情况下引擎可以选用<strong>SummingMergeTree</strong>，因为该引擎支持<strong>以主键分组</strong>，对数值型指标做自动累加。每当表的parts做后台merge的时候，主键相同的所有记录会被加和合并成一行记录，可以大大节省空间。</p><h4 id="实践" tabindex="-1"><a class="header-anchor" href="#实践" aria-hidden="true">#</a> 实践</h4>`,6),C={href:"https://mp.weixin.qq.com/s?__biz=Mzg3MTU2MTY5Nw==&mid=2247484678&idx=1&sn=aefc05096b87def5cb0907c75292d2d5&chksm=cefde588f98a6c9e4440bb07e6ed753325bb733bedcef06bdf708c061847482c5f10263fc716&mpshare=1&scene=1&srcid=1128sPOfzg4V9H953Kp2a9oC&sharer_sharetime=1669623285188&sharer_shareid=aedd72d7c0b9d4a1826b9a3022f6ce94&key=b74d2dd8e3b5765f95ee244dbcf0c3c6397046b469d2fcd94806e2868b95cab3b6b8e1ffa915a3900cbcf6621f1a76144e117245fa211af2b32817895ee11ebe53b8bdf35f4333d77264c039b1267f6211691a684c46e706fb6d6678dd386cf2d4b010c4ede60f0fbf08fbbb14b65d58d9c72fd9c04116415e0dbdc76d16cd87&ascene=1&uin=MTkwNjkxNDU1OA%3D%3D&devicetype=Windows+11+x64&version=63080021&lang=zh_CN&exportkey=n_ChQIAhIQtC%2BqwRDQkmJ2q4XdX1tMFBLlAQIE97dBBAEAAAAAAM6mDPqyGRkAAAAOpnltbLcz9gKNyK89dVj0MsjEgs3wWPDel1%2ForZG1%2BpXMEJYReQ3AEXH%2Bm3KS%2Fy7n3cTdz17onVUvFd2xy6Tg42c%2FtaGJ%2BnNCMmUDNZ4oTnRIE8TOWkEzOh62gXNkJIvkq188%2B8I7vHbNvChyepYP5ti6M02bi%2FLFLnreiGrrVeQNNcQGSxM1C5oewnusv%2F1jfm1D71ficzH25ebJHUdO%2BtYuv3kTPE1rJxUUp7h46Q2Nqjdkmtdfb5tyyIAtxldS%2FwdPqoAP7L82sRkhl6Q%3D&acctmode=0&pass_ticket=tLY%2F%2FIuKQjSmAhxZOoGuxuGZWkw7KWFM9JnoE4uFmzgOlc3%2Bd%2FwocWOQ1fhcrayA&wx_header=1&fontgear=2",target:"_blank",rel:"noopener noreferrer"},N={href:"https://github.com/IVitamin-C/clickhouse-learning",target:"_blank",rel:"noopener noreferrer"},L=t(`<h2 id="四、mysql迁移到clickhouse" tabindex="-1"><a class="header-anchor" href="#四、mysql迁移到clickhouse" aria-hidden="true">#</a> 四、MySql迁移到Clickhouse</h2><p>ClickHouse支持Mysql大多数语法，迁移成本低，目前有五种迁移方案：</p><ul><li>create table engin mysql，映射方案数据还是在Mysql</li><li>insert into select from，先建表，在导入</li><li>create table as select from，建表同时导入</li><li>csv离线导入</li><li>streamsets</li></ul><p><strong>建表同时导入</strong></p><p>以数据中台表为案例,在DBeaver连接clickhouse,执行sql:</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> b_chem_base
<span class="token keyword">ENGINE</span> <span class="token operator">=</span> MergeTree <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> id <span class="token keyword">AS</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> mysql<span class="token punctuation">(</span><span class="token string">&#39;[主机名]:3306&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;[数据库名]&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;[表名]&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;[用户名]&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;[密码]&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="五、mysql数据同步" tabindex="-1"><a class="header-anchor" href="#五、mysql数据同步" aria-hidden="true">#</a> 五、MySql数据同步</h2>`,7);function R(q,B){const n=o("ExternalLinkIcon");return i(),r("div",null,[c,d,s("ul",null,[s("li",null,[a("中文文档地址："),s("a",u,[a("什么是ClickHouse？ | ClickHouse Docs"),e(n)])]),s("li",null,[a("英文文档地址："),s("a",k,[a("Welcome to ClickHouse Docs | ClickHouse Docs"),e(n)])])]),h,v,s("ul",null,[s("li",null,[s("a",m,[a("OLAP分析引擎-Clickhouse 枫叶云笔记 (fynote.com)"),e(n)])]),s("li",null,[s("a",b,[a("ClickHouse入门：ubuntu安装ClickHouse_ClickHouse入门学习_大数据知识库 (saoniuhuo.com)"),e(n)])]),s("li",null,[s("a",g,[a("尚硅谷ClickHouse视频教程"),e(n)])])]),f,s("p",null,[a("[Clickhouse常用命令|阿里开发者社区]("),s("a",_,[a("https://developer.aliyun.com/article/713387#:~:text=ClickHouse常用命令"),e(n)]),a(" 2019-08-09 12324)")]),s("p",null,[s("a",x,[a("clickhouse常用操作命令|CSDN博客"),e(n)])]),E,s("p",null,[a("ClickHouse的分布式安装要依赖于Zookeeper，首先我们需要准备三台虚拟机，搭建Zookeeper的集群，具体步骤可以参考"),s("a",y,[a("VirtualBox搭建集群 | Zuoo (echoidf.github.io)"),e(n)])]),T,s("p",null,[a("前提：已经按照"),s("a",M,[a("VirtualBox搭建集群 | Zuoo (echoidf.github.io)"),e(n)]),a("搭建好Zookeeper集群")]),I,s("p",null,[a("参考："),s("a",S,[a("「ClickHouse系列」ClickHouse中的物化视图详解 - 腾讯云开发者社区-腾讯云 (tencent.com)"),e(n)])]),A,s("p",null,[s("a",C,[a("ClickHouse物化视图在微信的实战经验 (qq.com)"),e(n)])]),s("p",null,[s("a",N,[a("IVitamin-C/clickhouse-learning: ClickHouse学习之路，一起进步 (github.com)"),e(n)])]),L])}const V=l(p,[["render",R],["__file","clickhouse.html.vue"]]);export{V as default};
